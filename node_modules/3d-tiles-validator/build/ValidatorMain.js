"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorMain = void 0;
const path_1 = __importDefault(require("path"));
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const readJsonUnchecked_1 = require("./base/readJsonUnchecked");
const globMatcher_1 = require("./base/globMatcher");
const writeUnchecked_1 = require("./base/writeUnchecked");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const Validators_1 = require("./validation/Validators");
const ValidationOptions_1 = require("./validation/ValidationOptions");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
/**
 * A class summarizing the command-line functions of the validator.
 *
 * The functions in this class are supposed to be called from `main.ts`,
 * based on the parsed command line arguments.
 *
 * @internal
 */
class ValidatorMain {
    /**
     * Performs a run of the validator, using the given configuration settings.
     *
     * The configuration may contain properties that match the (long form
     * of the) command line arguments, as well as an `options: ValidationOptions`
     * object (using default options if none are given).
     *
     * @param args - The command line arguments (the `yargs` instance)
     * @param config - The configuration for the validator run
     */
    static async performValidation(args, config) {
        const validationOptions = (0, _3d_tiles_tools_3.defaultValue)(config.options, new ValidationOptions_1.ValidationOptions());
        if (config.tilesetFile) {
            const reportFileName = ValidatorMain.obtainReportFileName(config, config.tilesetFile);
            await ValidatorMain.validateTilesetFile(config.tilesetFile, reportFileName, validationOptions);
        }
        else if (config.tilesetsDirectory) {
            await ValidatorMain.validateTilesetsDirectory(config.tilesetsDirectory, config.tilesetGlobPattern, config.writeReports, validationOptions);
        }
        else if (config.metadataSchemaFile) {
            const reportFileName = ValidatorMain.obtainReportFileName(config, config.metadataSchemaFile);
            await ValidatorMain.validateSchemaFile(config.metadataSchemaFile, reportFileName);
        }
        else if (config.tilesetSpecs) {
            await ValidatorMain.validateAllTilesetSpecFiles(config.writeReports);
        }
        else if (config.metadataSchemaSpecs) {
            await ValidatorMain.validateAllMetadataSchemaSpecFiles(config.writeReports);
        }
        else if (config.subtreeSpecs) {
            await ValidatorMain.validateAllSubtreeSpecFiles(config.writeReports);
        }
        else {
            args.showHelp();
        }
    }
    /**
     * If a `reportFile` was specified in the given configuration,
     * then this is returned.
     *
     * Otherwise, if `writeReports` was specified, a report file
     * name is derived from the given file name and returned
     * (with the details about this name being unspecified for now).
     *
     * Otherwise, `undefined` is returned.
     *
     * @param config - The validation configuration
     * @param inputFileName - The input file name
     * @returns The report file name, or `undefined`
     */
    static obtainReportFileName(config, inputFileName) {
        if (config.reportFile) {
            return config.reportFile;
        }
        if (config.writeReports) {
            return ValidatorMain.deriveReportFileName(inputFileName);
        }
        return undefined;
    }
    static async validateTilesetFile(fileName, reportFileName, options) {
        console.log("Validating tileset " + fileName);
        const validationResult = await Validators_1.Validators.validateTilesetFile(fileName, options);
        if ((0, _3d_tiles_tools_1.defined)(reportFileName)) {
            await (0, writeUnchecked_1.writeUnchecked)(reportFileName, validationResult.serialize());
        }
        else {
            console.log("Validation result:");
            console.log(validationResult.serialize());
        }
        return validationResult;
    }
    static async validateTilesetsDirectory(directoryName, globPattern, writeReports, options) {
        console.log("Validating tilesets from " + directoryName + " matching " + globPattern);
        const recurse = true;
        const allFiles = _3d_tiles_tools_2.Iterables.overFiles(directoryName, recurse);
        const ignoreCase = true;
        const matcher = (0, globMatcher_1.globMatcher)(globPattern, ignoreCase);
        const tilesetFiles = _3d_tiles_tools_2.Iterables.filter(allFiles, matcher);
        let numFiles = 0;
        let numFilesWithErrors = 0;
        let numFilesWithWarnings = 0;
        let numFilesWithInfos = 0;
        for (const tilesetFile of tilesetFiles) {
            let reportFileName = undefined;
            if (writeReports) {
                reportFileName = ValidatorMain.deriveReportFileName(tilesetFile);
            }
            const validationResult = await ValidatorMain.validateTilesetFile(tilesetFile, reportFileName, options);
            numFiles++;
            if (validationResult.numErrors > 0) {
                numFilesWithErrors++;
            }
            if (validationResult.numWarnings > 0) {
                numFilesWithWarnings++;
            }
            if (validationResult.numInfos > 0) {
                numFilesWithInfos++;
            }
        }
        console.log(`Validated ${numFiles} files`);
        console.log(`    ${numFilesWithErrors} files with errors`);
        console.log(`    ${numFilesWithWarnings} files with warnings`);
        console.log(`    ${numFilesWithInfos} files with infos`);
    }
    static async validateSchemaFile(fileName, reportFileName) {
        console.log("Validating schema " + fileName);
        const validationResult = await Validators_1.Validators.validateSchemaFile(fileName);
        if ((0, _3d_tiles_tools_1.defined)(reportFileName)) {
            await (0, writeUnchecked_1.writeUnchecked)(reportFileName, validationResult.serialize());
        }
        else {
            console.log("Validation result:");
            console.log(validationResult.serialize());
        }
        return validationResult;
    }
    static async validateSubtreeFile(fileName, validationState, implicitTiling, reportFileName) {
        console.log("Validating subtree " + fileName);
        const validationResult = await Validators_1.Validators.validateSubtreeFile(fileName, validationState, implicitTiling);
        if ((0, _3d_tiles_tools_1.defined)(reportFileName)) {
            await (0, writeUnchecked_1.writeUnchecked)(reportFileName, validationResult.serialize());
        }
        else {
            console.log("Validation result:");
            console.log(validationResult.serialize());
        }
        return validationResult;
    }
    static async validateAllTilesetSpecFiles(writeReports) {
        const recurse = true;
        const allSpecFiles = _3d_tiles_tools_2.Iterables.overFiles(ValidatorMain.specsDataRootDir + "/tilesets", recurse);
        const ignoreCase = true;
        const matcher = (0, globMatcher_1.globMatcher)("**/*.json", ignoreCase);
        const specFiles = _3d_tiles_tools_2.Iterables.filter(allSpecFiles, matcher);
        for (const specFile of specFiles) {
            let reportFileName = undefined;
            if (writeReports) {
                reportFileName = ValidatorMain.deriveReportFileName(specFile);
            }
            await ValidatorMain.validateTilesetFile(specFile, reportFileName, undefined);
        }
    }
    static async validateAllMetadataSchemaSpecFiles(writeReports) {
        const recurse = false;
        const allSpecFiles = _3d_tiles_tools_2.Iterables.overFiles(ValidatorMain.specsDataRootDir + "schemas", recurse);
        const ignoreCase = true;
        const matcher = (0, globMatcher_1.globMatcher)("**/*.json", ignoreCase);
        const specFiles = _3d_tiles_tools_2.Iterables.filter(allSpecFiles, matcher);
        for (const specFile of specFiles) {
            let reportFileName = undefined;
            if (writeReports) {
                reportFileName = ValidatorMain.deriveReportFileName(specFile);
            }
            await ValidatorMain.validateSchemaFile(specFile, reportFileName);
        }
    }
    static async validateAllSubtreeSpecFiles(writeReports) {
        const recurse = false;
        const allSpecFiles = _3d_tiles_tools_2.Iterables.overFiles(ValidatorMain.specsDataRootDir + "subtrees", recurse);
        const ignoreCase = true;
        const matcher = (0, globMatcher_1.globMatcher)("**/{*.json,*.subtree}", ignoreCase);
        const specFiles = _3d_tiles_tools_2.Iterables.filter(allSpecFiles, matcher);
        for (const specFile of specFiles) {
            let reportFileName = undefined;
            if (writeReports) {
                reportFileName = ValidatorMain.deriveReportFileName(specFile);
            }
            await ValidatorMain.validateSubtreeSpecFile(specFile, reportFileName);
        }
    }
    static async validateSubtreeSpecFile(fileName, reportFileName) {
        let implicitTiling = undefined;
        let validationState = {
            hasSchemaDefinition: false,
            hasGroupsDefinition: false,
        };
        // The `TileImplicitTiling` object that defines the
        // structure of subtrees in the specs directory
        const specImplicitTiling = await (0, readJsonUnchecked_1.readJsonUnchecked)("specs/data/subtrees/validSubtreeImplicitTiling.json.input");
        implicitTiling = specImplicitTiling;
        // The `ValidationState` object that contains the
        // schema for the subtrees in the specs directory
        const specSchema = await (0, readJsonUnchecked_1.readJsonUnchecked)("specs/data/schemas/validSchema.json");
        const specValidationState = {
            hasSchemaDefinition: true,
            validatedSchema: specSchema,
            hasGroupsDefinition: false,
            validatedGroups: undefined,
        };
        validationState = specValidationState;
        await ValidatorMain.validateSubtreeFile(fileName, validationState, implicitTiling, reportFileName);
    }
    /**
     * Derives a file name for a report from the given input file name.
     * The resulting file name will be a file in the same directory as
     * the given one. Further details are intentionally not specified here.
     *
     * @param inputFileName - The input file name
     * @returns The report file name
     */
    static deriveReportFileName(inputFileName) {
        const basename = path_1.default.basename(inputFileName, path_1.default.extname(inputFileName));
        const extension = ".report.json";
        return path_1.default.join(path_1.default.dirname(inputFileName), basename + extension);
    }
}
exports.ValidatorMain = ValidatorMain;
ValidatorMain.specsDataRootDir = "specs/data/";
