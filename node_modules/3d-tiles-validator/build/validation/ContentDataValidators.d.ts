/// <reference types="node" />
import { Validator } from "./Validator";
import { ContentData } from "3d-tiles-tools";
/**
 * A class for managing `Validator` instances that are used for
 * validating the data that is pointed to by a `content.uri`.
 *
 * The only public method (for now) is `findContentDataValidator`,
 * which returns the validator that should be used for a given
 * `ContentData` object.
 *
 * @internal
 */
export declare class ContentDataValidators {
    /**
     * The validators that have been registered.
     *
     * See `registerDefaults` for details.
     */
    private static readonly dataValidators;
    /**
     * Whether the default content data validators have already
     * been registered by calling 'registerDefaults'
     *
     * Note: This could be solved with a static initializer block, but the
     * unclear initialization order of the classes would make this brittle
     */
    private static _registeredDefaults;
    /**
     * Registers all default content data validators
     */
    private static registerDefaults;
    /**
     * Creates a validator for content data that refers to a 3TZ package.
     *
     * This takes the contentData.uri, resolves it (to obtain an absolute URI),
     * and assumes that this URI is a path in the local file system, which
     * is then passed to the `TilesetPackageValidator`
     *
     * @returns The validator
     */
    private static createPackageValidator;
    /**
     * Creates a validator for content data that represents an external tileset.
     *
     * This validator will parse the JSON from the content data buffer, and
     * pass it to a default tileset validator.
     *
     * @returns The validator
     */
    private static createTilesetValidator;
    /**
     * Creates a validator for content data that represents glTF JSON data.
     *
     * This validator will pass the buffer with the JSON data to the
     * standard glTF validator.
     *
     * @returns The validator
     */
    private static createGltfJsonValidator;
    /**
     * Tries to find a data validator that can be used for validating
     * the given content data. If no matching validator can be found,
     * then `undefined` is returned.
     *
     * @param contentData - The `ContentData`
     * @returns The validator, or `undefined`
     */
    static findContentDataValidator(contentData: ContentData): Promise<Validator<ContentData> | undefined>;
    /**
     * Wraps the given validator for `Buffer` objects into one that
     * can be applied to `ContentData` objects, and just applies
     * the given validator to the buffer that is returned by
     * `ContentData#getData`.
     *
     * @param bufferValidator - The validator for `Buffer` objects
     * @returns The validator for `ContentData` objects
     */
    static wrapBufferValidator(bufferValidator: Validator<Buffer>): Validator<ContentData>;
    /**
     * Register a validator that should be used for the content
     * data buffer, when the content data has the type that is
     * indicated by the given name.
     *
     * @param contentDataTypeName - The content data type name
     * @param bufferValidator - The validator for the buffer data
     */
    private static registerForBuffer;
    /**
     * Registers a data validator that will be used when a
     * `ContentData` has the type that is indicated by the
     * given name.
     *
     * @param contentDataTypeName - The content data type name
     * @param dataValidator - The data validator
     */
    private static register;
}
//# sourceMappingURL=ContentDataValidators.d.ts.map