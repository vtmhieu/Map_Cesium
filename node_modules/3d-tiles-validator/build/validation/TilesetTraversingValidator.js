"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetTraversingValidator = void 0;
const path_1 = __importDefault(require("path"));
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const TileValidator_1 = require("./TileValidator");
const TileContentValidator_1 = require("./TileContentValidator");
const SubtreeValidator_1 = require("./SubtreeValidator");
const ImplicitTilingValidator_1 = require("./ImplicitTilingValidator");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
const MetadataEntityValidator_1 = require("./metadata/MetadataEntityValidator");
const _3d_tiles_tools_4 = require("3d-tiles-tools");
const SemanticValidationIssues_1 = require("../issues/SemanticValidationIssues");
const ValidationIssues_1 = require("../issues/ValidationIssues");
const StructureValidationIssues_1 = require("../issues/StructureValidationIssues");
/**
 * A validator for a `Tileset` that traverses the tile hierarchy
 * and performs the validation of the tile instances, their contents,
 * and the consistency of the tile hierarchy.
 *
 * @internal
 */
class TilesetTraversingValidator {
    /**
     * Validates the given tileset, by traversing the tile hierarchy
     * and validating each traversed tile.
     *
     * @param tileset - The `Tileset`
     * @param validationState - The `ValidationState`
     * @param context - The `TraversalContext`
     * @returns A promise that resolves when the validation is finished
     * and indicates whether every traversed tile was valid.
     */
    static async validateTileset(tileset, validationState, context) {
        const resourceResolver = context.getResourceResolver();
        let result = true;
        const tilesetTraverser = new _3d_tiles_tools_3.TilesetTraverser(".", resourceResolver, {
            depthFirst: true,
        });
        try {
            await tilesetTraverser.traverseWithSchema(tileset, validationState.validatedSchema, async (traversedTile) => {
                // Validate the tile, and only continue the traversal
                // if it was found to be valid
                const isValid = await TilesetTraversingValidator.validateTraversedTile(traversedTile, validationState, context);
                if (!isValid) {
                    result = false;
                }
                if (isValid) {
                    // If the traversed tile is generally valid, then
                    // validate its content
                    const contentValid = await TilesetTraversingValidator.validateTraversedTileContent(traversedTile, context);
                    if (!contentValid) {
                        result = false;
                    }
                    // If the traversed tile is not the root tile, validate
                    // the consistency of the hierarchy
                    const parent = traversedTile.getParent();
                    if ((0, _3d_tiles_tools_1.defined)(parent)) {
                        const hierarchyValid = TilesetTraversingValidator.validateTraversedTiles(parent, traversedTile, context);
                        if (!hierarchyValid) {
                            result = false;
                        }
                    }
                }
                return isValid;
            });
        }
        catch (error) {
            // There may be different kinds of errors that are thrown
            // during the traveral of the tileset and its validation.
            // An `ImplicitTilingError` indicates that an implicit
            // tileset was invalid (e.g. a missing subtree file or
            // one of its buffers). The `ImplicitTilingError` is
            // supposed to contain more detailed information.
            if (error instanceof _3d_tiles_tools_4.ImplicitTilingError) {
                const message = `Could not traverse tileset: ${error}`;
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.IMPLICIT_TILING_ERROR("", message);
                context.addIssue(issue);
                result = false;
            }
            else {
                // Other kinds of errors should not bubble up to the caller,
                // and are therefore collected here as `INTERNAL_ERROR`.
                // Whether or not this should cause the object to be
                // reported as "invalid" is up to debate. But to reduce
                // the number of follow-up errors, the object will be
                // reported as invalid here.
                const message = `Internal error while traversing tileset: ${error}`;
                const issue = ValidationIssues_1.ValidationIssues.INTERNAL_ERROR("", message);
                context.addIssue(issue);
                result = false;
            }
        }
        return result;
    }
    /**
     * Validates the given traversed tile.
     *
     * This will validate the tile that is represented with the given
     * traversed tile, so far that it ensures that it is a valid
     * tile object and can be traversed further.
     *
     * It will not validate the tile content. This is done with
     * `validateTraversedTileContent`
     *
     * @param traversedTile - The `TraversedTile`
     * @param validationState - The `ValidationState`
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateTraversedTile(traversedTile, validationState, context) {
        const path = traversedTile.path;
        // TODO The validation of the implicit tiling and the
        // metadata that are done here are redundant. They
        // are also done in `TileValidator#validateTile`.
        // It is not entirely clear which types of inconsistencies
        // should cause the validation to fail with which message.
        // Maybe some of these validation steps should be pulled
        // out of "validateTile", or enabled/disabled via flags.
        if (traversedTile instanceof _3d_tiles_tools_2.ExplicitTraversedTile) {
            const explicitPartIsValid = await TilesetTraversingValidator.validateExplicitTraversedTile(traversedTile, validationState, context);
            if (!explicitPartIsValid) {
                return false;
            }
        }
        const tile = traversedTile.asRawTile();
        // Validate the tile itself
        const tileValid = await TileValidator_1.TileValidator.validateTile(path, tile, validationState, context);
        if (!tileValid) {
            return false;
        }
        return true;
    }
    /**
     * Validates the given explicit traversed tile.
     *
     * This will ONLY validate the elements that are specific for
     * an `ExplicitTraversedTile` (compared to a `TraversedTile`) ,
     * namely the `implicitTiling` and `metadata` of the tile.
     *
     * @param traversedTile - The `ExplicitTraversedTile`
     * @param validationState - The `ValidationState`
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateExplicitTraversedTile(traversedTile, validationState, context) {
        const path = traversedTile.path;
        // If the tile defines implicit tiling, validate this
        // first. All subsequent checks depend on the validity
        // of the implicit tiling information.
        const implicitTiling = traversedTile.getImplicitTiling();
        const implicitTilingPath = path + "/implicitTiling";
        if ((0, _3d_tiles_tools_1.defined)(implicitTiling)) {
            if (!ImplicitTilingValidator_1.ImplicitTilingValidator.validateImplicitTiling(implicitTilingPath, implicitTiling, context)) {
                return false;
            }
            // If the tile is the root of a subtree, then
            // validate the subtree data
            const subtreeUri = traversedTile.getSubtreeUri();
            if ((0, _3d_tiles_tools_1.defined)(subtreeUri)) {
                const subtreeRootValid = await TilesetTraversingValidator.validateSubtreeRoot(path, implicitTiling, subtreeUri, validationState, context);
                if (!subtreeRootValid) {
                    return false;
                }
            }
        }
        // Validate the metadata.
        // This is also done in `TileValidator#validateTile`, but
        // the following steps require the metadata to already be
        // valid.
        const metadata = traversedTile.getMetadata();
        const metadataPath = path + "/metadata";
        if ((0, _3d_tiles_tools_1.defined)(metadata)) {
            if (!validationState.hasSchemaDefinition) {
                // If there is metadata, then there must be a schema definition
                const message = "The tile defines 'metadata' but the tileset does not have a schema";
                const issue = StructureValidationIssues_1.StructureValidationIssues.REQUIRED_VALUE_NOT_FOUND(path, message);
                context.addIssue(issue);
                return false;
            }
            if ((0, _3d_tiles_tools_1.defined)(validationState.validatedSchema)) {
                if (!MetadataEntityValidator_1.MetadataEntityValidator.validateMetadataEntity(metadataPath, "tile.metadata", metadata, validationState.validatedSchema, context)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Validates the content in given traversed tile.
     *
     * This assumes that the given tile already has been determined to
     * be basically valid, as of `validateTraversedTile`.
     *
     * @param traversedTile - The `TraversedTile`
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateTraversedTileContent(traversedTile, context) {
        const tile = traversedTile.asRawTile();
        let result = true;
        // Validate the content
        const content = tile.content;
        const contentPath = traversedTile.path + "/content";
        if ((0, _3d_tiles_tools_1.defined)(content)) {
            const contentResult = await TileContentValidator_1.TileContentValidator.validateTileContent(contentPath, content, tile, context);
            if (!contentResult) {
                result = false;
            }
        }
        // Validate the contents
        const contents = tile.contents;
        const contentsPath = traversedTile.path + "/contents";
        if ((0, _3d_tiles_tools_1.defined)(contents)) {
            for (let i = 0; i < contents.length; i++) {
                const contentsElement = contents[i];
                const contentsElementPath = contentsPath + "/" + i;
                const contentResult = await TileContentValidator_1.TileContentValidator.validateTileContent(contentsElementPath, contentsElement, tile, context);
                if (!contentResult) {
                    result = false;
                }
            }
        }
        return result;
    }
    /**
     * Performs the validation to make sure that the specified subtree
     * root is valid.
     *
     * This will attempt to resolve the `.subtree` (or subtree JSON)
     * data from the URI that is created by substituting the given
     * coordinates into the subtree template URI of the implicit tiling,
     * resolve the resulting data, and pass it to a `SubtreeValidator`.
     *
     * @param tilePath - The path for `ValidationIssue` instances
     * @param implicitTiling - The `TileImpllicitTiling`
     * @param subtreeUri - The subtree URI
     * @param validationState - The `ValidationState`
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateSubtreeRoot(tilePath, implicitTiling, subtreeUri, validationState, context) {
        // Resolve resources (like buffers) relative to the
        // directory of the subtree file
        const resourceResolver = context.getResourceResolver();
        const subtreeDirectory = path_1.default.dirname(subtreeUri);
        const subtreeResourceResolver = resourceResolver.derive(subtreeDirectory);
        // Obtain the raw subtree data (binary subtree file or JSON)
        const subtreeData = await resourceResolver.resolveData(subtreeUri);
        if (subtreeData == null) {
            const message = `Could not resolve subtree URI ${subtreeUri} that was ` +
                `created from template URI ${implicitTiling.subtrees.uri} `;
            const issue = SemanticValidationIssues_1.SemanticValidationIssues.TILE_IMPLICIT_ROOT_INVALID(tilePath, message);
            context.addIssue(issue);
            return false;
        }
        // Validate the subtree data with a `SubtreeValidator`
        const subtreeValidator = new SubtreeValidator_1.SubtreeValidator(validationState, implicitTiling, subtreeResourceResolver);
        const result = await subtreeValidator.validateObject(subtreeUri, subtreeData, context);
        return result;
    }
    /**
     * Validate the consistency of the given traversed tile instances.
     *
     * This will check the conditions that must hold for parent/child
     * tiles, for example, the consistency of the geometric error
     *
     * @param traversedParent - The parent `TraversedTile`
     * @param traversedTile - The current `TraversedTile`
     * @param context - The `ValidationContext`
     */
    static validateTraversedTiles(traversedParent, traversedTile, context) {
        const path = traversedTile.path;
        const tile = traversedTile.asRawTile();
        const parent = traversedParent.asRawTile();
        // Validate that the parent geometricError is not larger
        // than the tile geometricError
        const parentGeometricError = parent.geometricError;
        const tileGeometricError = tile.geometricError;
        if ((0, _3d_tiles_tools_1.defined)(tileGeometricError) &&
            (0, _3d_tiles_tools_1.defined)(parentGeometricError) &&
            tileGeometricError > parentGeometricError) {
            const message = `Tile ${path} has a geometricError of ${tileGeometricError}, ` +
                `which is larger than the parent geometricError ` +
                `of ${parentGeometricError}`;
            const issue = SemanticValidationIssues_1.SemanticValidationIssues.TILE_GEOMETRIC_ERRORS_INCONSISTENT(path, message);
            context.addIssue(issue);
            return false;
        }
        return true;
    }
}
exports.TilesetTraversingValidator = TilesetTraversingValidator;
