"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendedObjectsValidators = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const SemanticValidationIssues_1 = require("../issues/SemanticValidationIssues");
/**
 * A class for managing the validation of objects that contain extensions.
 *
 * It allows registering `Validator` objects for specific extension
 * names. The `validateExtendedObject` function will be called for
 * each `RootProperty` (i.e. for each object that may contain
 * extensions). When an object contains an extension with one
 * of the registered names, then the respective validators will
 * be applied to that object.
 *
 * @internal
 */
class ExtendedObjectsValidators {
    /**
     * Registers a validator for an object with the specified extension.
     *
     * When an object has the specified extension, then the given
     * validator will be applied to this object.
     *
     * @param extensionName - The name of the extension
     * @param extendedObjectValidator - The `Validator` for the extended objects
     * @param override - Whether the given validator should replace the
     * default validation. This can be queried with the `hasOverride` method.
     */
    static register(extensionName, extendedObjectValidator, override) {
        ExtendedObjectsValidators.extendedObjectValidators.set(extensionName, extendedObjectValidator);
        ExtendedObjectsValidators.overrides.set(extensionName, override);
    }
    /**
     * Returns whether the default validation of the given object
     * is overridden. This is the case when the object contains
     * an extension which has been registered by calling the
     * `register` method, with the `override` flag being `true`.
     *
     * @param rootProperty - The `RootProperty`
     * @returns Whether the default validation is overridden
     * by one of the registered validators.
     */
    static hasOverride(rootProperty) {
        const extensions = rootProperty.extensions;
        if (!(0, _3d_tiles_tools_1.defined)(extensions)) {
            return false;
        }
        const extensionNames = Object.keys(extensions);
        for (const extensionName of extensionNames) {
            const override = ExtendedObjectsValidators.overrides.get(extensionName);
            if (override === true) {
                return true;
            }
        }
        return false;
    }
    /**
     * Perform the validation of the given (possibly extended) object.
     *
     * If the given object does not have extensions, then `true` will
     * be returned.
     *
     * If there are extensions, then each of them will be examined:
     *
     * If a `Validator` instance has been registered for one of the
     * extensions (by calling the `register` method), then this
     * validator will be applied to the given object.
     *
     * (If no `Validator` instance has been registered, then
     * a warning will be added to the given context, indicating
     * that the extension is not supported)
     *
     * If any of the registered validators returns `false`, then
     * `false` will be returned. If all of them consider the object
     * to be valid, then `true` will be returned.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param rootProperty - The `RootProperty` that may contain extensions
     * @param context - The `ValidationContext`
     * @returns Whether the object is valid
     */
    static async validateExtendedObject(path, rootProperty, context) {
        // If there are no extensions, consider the object to be valid
        const extensions = rootProperty.extensions;
        if (!(0, _3d_tiles_tools_1.defined)(extensions)) {
            return true;
        }
        // The extensions MUST be an object. This is checked and reported
        // by the RootPropertyValidator, and therefore, will not reported
        // again here
        if (typeof extensions !== "object") {
            return true;
        }
        let allValid = true;
        const extensionNames = Object.keys(extensions);
        for (const extensionName of extensionNames) {
            const extendedObjectValidator = ExtendedObjectsValidators.extendedObjectValidators.get(extensionName);
            // If an extension was found, but no validator for
            // that extension was registered, then issue a
            // warning.
            if (!(0, _3d_tiles_tools_1.defined)(extendedObjectValidator)) {
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.EXTENSION_NOT_SUPPORTED(path, extensionName);
                context.addIssue(issue);
            }
            else {
                // Validate the object with the registered Validator
                const isValid = await extendedObjectValidator.validateObject(path, rootProperty, context);
                if (!isValid) {
                    allValid = false;
                }
            }
        }
        return allValid;
    }
}
exports.ExtendedObjectsValidators = ExtendedObjectsValidators;
/**
 * The mapping from extension names to the validators that
 * are used for objects that contain the respective extension.
 */
ExtendedObjectsValidators.extendedObjectValidators = new Map();
/**
 * The mapping from extension names to the flag that indicates
 * whether the corresponding validator should override the
 * default validation process.
 */
ExtendedObjectsValidators.overrides = new Map();
