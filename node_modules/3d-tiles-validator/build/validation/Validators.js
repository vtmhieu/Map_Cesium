"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validators = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
const TilesetValidator_1 = require("./TilesetValidator");
const ValidationContext_1 = require("./ValidationContext");
const SubtreeValidator_1 = require("./SubtreeValidator");
const ExtendedObjectsValidators_1 = require("./ExtendedObjectsValidators");
const TilesetPackageValidator_1 = require("./TilesetPackageValidator");
const SchemaValidator_1 = require("./metadata/SchemaValidator");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const ContentValidationIssues_1 = require("../issues/ContentValidationIssues");
const BoundingVolumeS2Validator_1 = require("./extensions/BoundingVolumeS2Validator");
/**
 * Utility methods related to `Validator` instances.
 *
 * @beta
 */
class Validators {
    /**
     * Creates a `TilesetValidator` with an unspecified default configuration.
     *
     * @returns The `TilesetValidator`
     * @internal
     */
    static createDefaultTilesetValidator() {
        const validator = new TilesetValidator_1.TilesetValidator();
        return validator;
    }
    /**
     * Performs a default validation of the given tileset file, and
     * returns a promise to the `ValidationResult`.
     *
     * The given file may be a `tileset.json` file, or a tileset
     * package file, as incdicated by a `.3tz` or `.3dtiles` file
     * extensions.
     *
     * @param filePath - The file path
     * @param validationOptions - The `ValidationOptions`. When this
     * is not given (or `undefined`), then default validation options
     * will be used. See {@link ValidationOptions}.
     * @returns A promise to a `ValidationResult` that is fulfilled when
     * the validation finished.
     * @beta
     */
    static async validateTilesetFile(filePath, validationOptions) {
        const extension = path_1.default.extname(filePath).toLowerCase();
        const isDirectory = fs_1.default.statSync(filePath).isDirectory();
        const packageExtensions = [".3tz", ".3dtiles"];
        const isPackage = packageExtensions.includes(extension);
        if (isPackage || isDirectory) {
            const validationResult = await Validators.validateTilesetPackageInternal(filePath, validationOptions);
            return validationResult;
        }
        const validationResult = await Validators.validateTilesetFileInternal(filePath, validationOptions);
        return validationResult;
    }
    /**
     * Performs a default validation of the given `tileset.json` file, and
     * returns a promise to the `ValidationResult`.
     *
     * @param filePath - The file path
     * @param validationOptions - The `ValidationOptions`. When this
     * is not given (or `undefined`), then default validation options
     * will be used. See {@link ValidationOptions}.
     * @returns A promise to a `ValidationResult` that is fulfilled when
     * the validation finished.
     * @beta
     */
    static async validateTilesetFileInternal(filePath, validationOptions) {
        Validators.registerExtensionValidators();
        const directory = path_1.default.dirname(filePath);
        const fileName = path_1.default.basename(filePath);
        const resourceResolver = _3d_tiles_tools_3.ResourceResolvers.createFileResourceResolver(directory);
        const validator = Validators.createDefaultTilesetValidator();
        const context = new ValidationContext_1.ValidationContext(directory, resourceResolver, validationOptions);
        const tilesetUri = context.resolveUri(fileName);
        context.addActiveTilesetUri(tilesetUri);
        const resourceData = await resourceResolver.resolveData(fileName);
        if (!(0, _3d_tiles_tools_1.defined)(resourceData)) {
            const message = `Could not read input file: ${filePath}`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(filePath, message);
            context.addIssue(issue);
        }
        else {
            const bom = _3d_tiles_tools_2.Buffers.getUnicodeBOMDescription(resourceData);
            if ((0, _3d_tiles_tools_1.defined)(bom)) {
                const message = `Unexpected BOM in JSON buffer: ${bom}`;
                const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(filePath, message);
                context.addIssue(issue);
            }
            else {
                const jsonString = resourceData.toString();
                await validator.validateJsonString(jsonString, context);
            }
        }
        context.removeActiveTilesetUri(tilesetUri);
        return context.getResult();
    }
    /**
     * Performs a default validation of the given tileset package file, and
     * returns a promise to the `ValidationResult`.
     *
     * The given path may be a path of a `.3tz` or a `.3dtiles` file (or
     * a directory that contains a 'tileset.json' file)
     *
     * @param filePath - The file path
     * @param validationOptions - The `ValidationOptions`. When this
     * is not given (or `undefined`), then default validation options
     * will be used. See {@link ValidationOptions}.
     * @returns A promise to a `ValidationResult` that is fulfilled when
     * the validation finished.
     * @beta
     */
    static async validateTilesetPackageInternal(filePath, validationOptions) {
        Validators.registerExtensionValidators();
        const directory = path_1.default.dirname(filePath);
        const resourceResolver = _3d_tiles_tools_3.ResourceResolvers.createFileResourceResolver(directory);
        const context = new ValidationContext_1.ValidationContext(directory, resourceResolver, validationOptions);
        const tilesetUri = context.resolveUri(filePath);
        context.addActiveTilesetUri(tilesetUri);
        await TilesetPackageValidator_1.TilesetPackageValidator.validatePackageFile(filePath, context);
        context.removeActiveTilesetUri(tilesetUri);
        return context.getResult();
    }
    /**
     * Creates a `SchemaValidator` with an unspecified default configuration.
     *
     * @returns The `SchemaValidator`
     * @internal
     */
    static createDefaultSchemaValidator() {
        const validator = new SchemaValidator_1.SchemaValidator();
        return validator;
    }
    /**
     * Performs a default validation of the given schema JSON file, and
     * returns a promise to the `ValidationResult`.
     *
     * @param filePath - The file path
     * @returns A promise to a `ValidationResult` that is fulfilled when
     * the validation finished.
     * @internal
     */
    static async validateSchemaFile(filePath) {
        const directory = path_1.default.dirname(filePath);
        const fileName = path_1.default.basename(filePath);
        const resourceResolver = _3d_tiles_tools_3.ResourceResolvers.createFileResourceResolver(directory);
        const resourceData = await resourceResolver.resolveData(fileName);
        const validator = Validators.createDefaultSchemaValidator();
        const context = new ValidationContext_1.ValidationContext(directory, resourceResolver);
        const jsonString = resourceData ? resourceData.toString() : "";
        await validator.validateJsonString(jsonString, context);
        return context.getResult();
    }
    /**
     * Creates a `SubtreeValidator` with an unspecified default configuration.
     *
     * @returns The `SubtreeValidator`
     * @internal
     */
    static createDefaultSubtreeValidator(uri, validationState, implicitTiling) {
        const directory = path_1.default.dirname(uri);
        const resourceResolver = _3d_tiles_tools_3.ResourceResolvers.createFileResourceResolver(directory);
        const validator = new SubtreeValidator_1.SubtreeValidator(validationState, implicitTiling, resourceResolver);
        return validator;
    }
    /**
     * Performs a default validation of the given subtree JSON file, and
     * returns a promise to the `ValidationResult`.
     *
     * @param filePath - The file path
     * @returns A promise to a `ValidationResult` that is fulfilled when
     * the validation finished.
     * @internal
     */
    static async validateSubtreeFile(filePath, validationState, implicitTiling) {
        const directory = path_1.default.dirname(filePath);
        const fileName = path_1.default.basename(filePath);
        const resourceResolver = _3d_tiles_tools_3.ResourceResolvers.createFileResourceResolver(directory);
        const resourceData = await resourceResolver.resolveData(fileName);
        const validator = Validators.createDefaultSubtreeValidator(filePath, validationState, implicitTiling);
        const context = new ValidationContext_1.ValidationContext(directory, resourceResolver);
        if (!(0, _3d_tiles_tools_1.defined)(resourceData)) {
            const message = `Could not read subtree file ${filePath}`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(filePath, message);
            context.addIssue(issue);
        }
        else {
            await validator.validateObject(filePath, resourceData, context);
        }
        return context.getResult();
    }
    /**
     * Creates a validator for `Buffer` objects that parses an
     * object of type `T` from the (JSON) string representation
     * of the buffer contents, and applies the given delegate
     * to the result.
     *
     * If the object cannot be parsed, a `JSON_PARSE_ERROR`
     * will be added to the given context.
     *
     * @param delegate - The delegate
     * @returns The new validator
     * @internal
     */
    static parseFromBuffer(delegate) {
        return {
            async validateObject(inputPath, input, context) {
                try {
                    const bom = _3d_tiles_tools_2.Buffers.getUnicodeBOMDescription(input);
                    if ((0, _3d_tiles_tools_1.defined)(bom)) {
                        const message = `Unexpected BOM in JSON buffer: ${bom}`;
                        const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(inputPath, message);
                        context.addIssue(issue);
                        return false;
                    }
                    const object = JSON.parse(input.toString());
                    const delegateResult = await delegate.validateObject(inputPath, object, context);
                    return delegateResult;
                }
                catch (error) {
                    const message = `${error}`;
                    const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(inputPath, message);
                    context.addIssue(issue);
                    return false;
                }
            },
        };
    }
    /**
     * Creates a `Validator` that only adds a `CONTENT_VALIDATION_WARNING`
     * with the given message to the given context when it is called.
     *
     * This is used for "dummy" validators that handle content data types
     * that are already anticipated (like VCTR or GEOM), but not validated
     * explicitly.
     *
     * @param message - The message for the warning
     * @returns The new validator
     * @internal
     */
    static createContentValidationWarning(message) {
        return {
            async validateObject(inputPath, 
            //eslint-disable-next-line @typescript-eslint/no-unused-vars
            input, context) {
                const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_WARNING(inputPath, message);
                context.addIssue(issue);
                return true;
            },
        };
    }
    /**
     * Creates an empty validator that does nothing.
     *
     * This is used for "dummy" validators for content types that
     * are ignored.
     *
     * @returns The new validator
     * @internal
     */
    static createEmptyValidator() {
        return {
            async validateObject(
            //eslint-disable-next-line @typescript-eslint/no-unused-vars
            inputPath, 
            //eslint-disable-next-line @typescript-eslint/no-unused-vars
            input, 
            //eslint-disable-next-line @typescript-eslint/no-unused-vars
            context) {
                return true;
            },
        };
    }
    /**
     * Register the validators for known extensions
     */
    static registerExtensionValidators() {
        if (Validators._registeredExtensionValidators) {
            return;
        }
        // Register the validator for 3DTILES_bounding_volume_S2
        {
            const s2Validator = new BoundingVolumeS2Validator_1.BoundingVolumeS2Validator();
            const override = true;
            ExtendedObjectsValidators_1.ExtendedObjectsValidators.register("3DTILES_bounding_volume_S2", s2Validator, override);
        }
        // Register an empty validator for 3DTILES_content_gltf
        // (The extension does not have any properties to be
        // validated)
        {
            const emptyValidator = Validators.createEmptyValidator();
            const override = false;
            ExtendedObjectsValidators_1.ExtendedObjectsValidators.register("3DTILES_content_gltf", emptyValidator, override);
        }
        Validators._registeredExtensionValidators = true;
    }
}
exports.Validators = Validators;
/**
 * Whether the knows extension validators have already been registered
 * by calling `registerExtensionValidators`.
 *
 * Note: This could be solved with a static initializer block, but the
 * unclear initialization order of the classes would make this brittle
 */
Validators._registeredExtensionValidators = false;
