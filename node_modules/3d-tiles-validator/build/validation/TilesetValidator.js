"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const BasicValidator_1 = require("./BasicValidator");
const PropertiesValidator_1 = require("./PropertiesValidator");
const StatisticsValidator_1 = require("./StatisticsValidator");
const AssetValidator_1 = require("./AssetValidator");
const TilesetTraversingValidator_1 = require("./TilesetTraversingValidator");
const RootPropertyValidator_1 = require("./RootPropertyValidator");
const ExtendedObjectsValidators_1 = require("./ExtendedObjectsValidators");
const SchemaValidator_1 = require("./metadata/SchemaValidator");
const MetadataEntityValidator_1 = require("./metadata/MetadataEntityValidator");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const StructureValidationIssues_1 = require("../issues/StructureValidationIssues");
const JsonValidationIssues_1 = require("../issues/JsonValidationIssues");
const SemanticValidationIssues_1 = require("../issues/SemanticValidationIssues");
/**
 * A class that can validate a 3D Tiles tileset.
 *
 * @internal
 */
class TilesetValidator {
    /**
     * Performs the validation of the tileset that is parsed from the
     * given input string.
     *
     * @param input - The string that was read from a `tileset.json` file
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    async validateJsonString(input, context) {
        try {
            const object = JSON.parse(input);
            await this.validateObject("", object, context);
        }
        catch (error) {
            //console.log(error);
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR("", "" + error);
            context.addIssue(issue);
        }
    }
    /**
     * Implementation of the `Validator` interface that just passes the
     * input to `validateTileset`.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param input - The `Tileset` object
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     * and indicates whether the object was valid or not.
     */
    async validateObject(path, input, context) {
        const result = await TilesetValidator.validateTileset(path, input, context);
        return result;
    }
    /**
     * Performs the validation of the given `Tileset` object that was parsed
     * from a `tileset.json` input.
     *
     * Issues that are encountered during the validation will be added
     * as `ValidationIssue` instances to the given `ValidationContext`.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param tileset - The `Tileset` object
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     * and indicates whether the object was valid or not.
     */
    static async validateTileset(path, tileset, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(path, "tileset", tileset, context)) {
            return false;
        }
        let result = true;
        // Validate the object as a RootProperty
        if (!RootPropertyValidator_1.RootPropertyValidator.validateRootProperty(path, "tileset", tileset, context)) {
            result = false;
        }
        // Perform the validation of the object in view of the
        // extensions that it may contain
        if (!ExtendedObjectsValidators_1.ExtendedObjectsValidators.validateExtendedObject(path, tileset, context)) {
            result = false;
        }
        // If there was an extension validator that overrides the
        // default validation, then skip the remaining validation.
        if (ExtendedObjectsValidators_1.ExtendedObjectsValidators.hasOverride(tileset)) {
            return result;
        }
        // The asset MUST be defined
        const asset = tileset.asset;
        if (!AssetValidator_1.AssetValidator.validateAsset(asset, context)) {
            result = false;
        }
        // Validate the properties (I mean, the `properties`...)
        const properties = tileset.properties;
        if ((0, _3d_tiles_tools_1.defined)(properties)) {
            if (!PropertiesValidator_1.PropertiesValidator.validateProperties(properties, context)) {
                result = false;
            }
        }
        // The schema and schemaUri MUST NOT be present at the same time
        if ((0, _3d_tiles_tools_1.defined)(tileset.schema) && (0, _3d_tiles_tools_1.defined)(tileset.schemaUri)) {
            const issue = JsonValidationIssues_1.JsonValidationIssues.ONE_OF_ERROR(path, "tileset", "schema", "schemaUri");
            context.addIssue(issue);
            result = false;
        }
        // Validate the schemaUri
        const schemaUri = tileset.schemaUri;
        const schemaUriPath = path + "/schemaUri";
        if ((0, _3d_tiles_tools_1.defined)(schemaUri)) {
            // The schemaUri MUST be a string
            if (!BasicValidator_1.BasicValidator.validateString(schemaUriPath, "schemaUri", schemaUri, context)) {
                result = false;
            }
        }
        // Create the ValidationState, and fill it with information
        // about the presence of a schema, and the validated schema
        // (if the schema is valid)
        const validationState = {
            validatedSchema: undefined,
            hasSchemaDefinition: false,
            validatedGroups: undefined,
            hasGroupsDefinition: false,
        };
        const schemaResult = await TilesetValidator.resolveTilesetSchema(tileset, context);
        validationState.hasSchemaDefinition = schemaResult.hasSchemaDefinition;
        // Validate the schema
        const schema = schemaResult.schema;
        const schemaPath = path + "/schema";
        if ((0, _3d_tiles_tools_1.defined)(schema)) {
            if (SchemaValidator_1.SchemaValidator.validateSchema(schemaPath, schema, context)) {
                validationState.validatedSchema = schema;
            }
            else {
                result = false;
            }
        }
        // Validate the groups.
        const groups = tileset.groups;
        const groupsPath = path + "/groups";
        if ((0, _3d_tiles_tools_1.defined)(groups)) {
            validationState.hasGroupsDefinition = true;
            // If there are groups, then there must be a schema definition
            if (!validationState.hasSchemaDefinition) {
                const message = "The tileset defines 'groups' but does not have a schema";
                const issue = StructureValidationIssues_1.StructureValidationIssues.REQUIRED_VALUE_NOT_FOUND(groupsPath, message);
                context.addIssue(issue);
            }
            else if ((0, _3d_tiles_tools_1.defined)(validationState.validatedSchema)) {
                if (TilesetValidator.validateTilesetGroups(groups, validationState.validatedSchema, context)) {
                    validationState.validatedGroups = groups;
                }
                else {
                    result = false;
                }
            }
        }
        // Validate the statistics
        const statistics = tileset.statistics;
        const statisticsPath = path + "/statistics";
        if ((0, _3d_tiles_tools_1.defined)(statistics)) {
            if (!StatisticsValidator_1.StatisticsValidator.validateStatistics(statisticsPath, statistics, validationState, context)) {
                result = false;
            }
        }
        // Validate the geometricError
        const geometricError = tileset.geometricError;
        const geometricErrorPath = "/geometricError";
        // The geometricError MUST be defined
        // The geometricError MUST be a number
        // The geometricError MUST be >= 0
        if (!BasicValidator_1.BasicValidator.validateNumberRange(geometricErrorPath, "geometricError", geometricError, 0.0, true, undefined, false, context)) {
            result = false;
        }
        // Validate the metadata
        const metadata = tileset.metadata;
        const metadataPath = path + "/metadata";
        if ((0, _3d_tiles_tools_1.defined)(metadata)) {
            if (!validationState.hasSchemaDefinition) {
                // If there is metadata, then there MUST be a schema definition
                const message = `The tileset defines metadata, but ` +
                    `there was no schema definition`;
                const issue = StructureValidationIssues_1.StructureValidationIssues.REQUIRED_VALUE_NOT_FOUND(path, message);
                context.addIssue(issue);
            }
            else if ((0, _3d_tiles_tools_1.defined)(validationState.validatedSchema)) {
                if (!MetadataEntityValidator_1.MetadataEntityValidator.validateMetadataEntity(metadataPath, "metadata", metadata, validationState.validatedSchema, context)) {
                    result = false;
                }
            }
        }
        const traversalValid = await TilesetTraversingValidator_1.TilesetTraversingValidator.validateTileset(tileset, validationState, context);
        if (!traversalValid) {
            result = false;
        }
        if (!TilesetValidator.validateExtensionDeclarations(path, tileset, context)) {
            result = false;
        }
        return result;
    }
    /**
     * Validate the extension declarations of the given tileset.
     *
     * This is supposed to be called at the end of the validation process
     * of the tileset. It uses the extension names that have been added
     * to the `ValidationContext` via `addExtensionFound`, to make sure
     * that all extensions that are found have also been declared in
     * the 'extensionsUsed' array.
     *
     * It also performs the JSON-schema level validation of the basic
     * structure and consistency of the 'extensionsUsed' and
     * 'extensionsRequired' arrays of the given tileset.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param tileset - The `Tileset`
     * @param context - The `ValidationContext`
     * @returns Whether the declarations have been valid
     */
    static validateExtensionDeclarations(path, tileset, context) {
        let result = true;
        // These are the actual sets of unique string values that
        // are found in 'extensionsUsed' and 'extensionsRequired'
        const actualExtensionsUsed = new Set();
        const actualExtensionsRequired = new Set();
        // Validate the extensionsUsed
        const extensionsUsed = tileset.extensionsUsed;
        const extensionsUsedPath = path + "/extensionsUsed";
        if ((0, _3d_tiles_tools_1.defined)(extensionsUsed)) {
            // The extensionsUsed MUST be an array of strings with
            // a length of at least 1
            if (!BasicValidator_1.BasicValidator.validateArray(extensionsUsedPath, "extensionsUsed", extensionsUsed, 1, undefined, "string", context)) {
                result = false;
            }
            else {
                extensionsUsed.forEach((e) => actualExtensionsUsed.add(e));
                // The elements in extensionsUsed MUST be unique
                BasicValidator_1.BasicValidator.validateArrayElementsUnique(extensionsUsedPath, "extensionsUsed", extensionsUsed, context);
            }
        }
        // Validate the extensionsRequired
        const extensionsRequired = tileset.extensionsRequired;
        const extensionsRequiredPath = path + "/extensionsRequired";
        if ((0, _3d_tiles_tools_1.defined)(extensionsRequired)) {
            // The extensionsRequired MUST be an array of strings with
            // a length of at least 1
            if (!BasicValidator_1.BasicValidator.validateArray(extensionsRequiredPath, "extensionsRequired", extensionsRequired, 1, undefined, "string", context)) {
                result = false;
            }
            else {
                extensionsRequired.forEach((e) => actualExtensionsRequired.add(e));
                // The elements in extensionsRequired MUST be unique
                BasicValidator_1.BasicValidator.validateArrayElementsUnique(extensionsRequiredPath, "extensionsRequired", extensionsRequired, context);
            }
        }
        // Each extension in extensionsRequired MUST also
        // appear in extensionsUsed.
        for (const extensionName of actualExtensionsRequired) {
            if (!actualExtensionsUsed.has(extensionName)) {
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.EXTENSION_REQUIRED_BUT_NOT_USED(extensionsUsedPath, extensionName);
                context.addIssue(issue);
                result = false;
            }
        }
        // Each extension that is found during the validation
        // in the `RootPropertyValidator` or the
        // `ContentDataValidator` also has to appear
        // in the 'extensionsUsed'
        const actualExtensionsFound = context.getExtensionsFound();
        // TODO: A cleaner solution has to be found for this. See
        // https://github.com/CesiumGS/3d-tiles-validator/issues/231
        if (tileset.asset?.version === "1.1") {
            actualExtensionsFound.delete("3DTILES_content_gltf");
        }
        for (const extensionName of actualExtensionsFound) {
            if (!actualExtensionsUsed.has(extensionName)) {
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.EXTENSION_FOUND_BUT_NOT_USED(extensionsUsedPath, extensionName);
                context.addIssue(issue);
                result = false;
            }
        }
        // Each extension that is declared in the 'extensionsUsed'
        // should also appear in the extensions that are found
        // (but it does not have to - so this is just a warning)
        for (const extensionName of actualExtensionsUsed) {
            if (!actualExtensionsFound.has(extensionName)) {
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.EXTENSION_USED_BUT_NOT_FOUND(extensionsUsedPath, extensionName);
                context.addIssue(issue);
            }
        }
        return result;
    }
    /**
     * Resolves the schema for the given tileset.
     *
     * The result will be an object with the following properties:
     *
     * `hasSchemaDefinition`: This is `true` if there either was a
     * `tileset.schema` or a `tileset.schemaUri`
     *
     * `schema`: This is either the `tileset.schema`, or the
     * schema that was read from the `tileset.schemaUri`. If
     * the latter could not be resolved, `schema` will be
     * `undefined`.
     *
     * @param tileset - The `Tileset` object
     * @param context - The `ValidationContext`
     * @returns A promise that resolves with the result object
     */
    static async resolveTilesetSchema(tileset, context) {
        const schema = tileset.schema;
        const schemaUri = tileset.schemaUri;
        if ((0, _3d_tiles_tools_1.defined)(schema) && typeof schema === "object") {
            return {
                hasSchemaDefinition: true,
                schema: schema,
            };
        }
        if ((0, _3d_tiles_tools_1.defined)(schemaUri) && typeof schemaUri === "string") {
            const resourceResolver = context.getResourceResolver();
            const schemaBuffer = await resourceResolver.resolveData(schemaUri);
            if (!(0, _3d_tiles_tools_1.defined)(schemaBuffer)) {
                const path = "/schemaUri";
                const message = `The 'schemaUri' is '${schemaUri}' and could not be resolved`;
                const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(path, message);
                context.addIssue(issue);
                return {
                    hasSchemaDefinition: true,
                    schema: undefined,
                };
            }
            const bom = _3d_tiles_tools_2.Buffers.getUnicodeBOMDescription(schemaBuffer);
            if ((0, _3d_tiles_tools_1.defined)(bom)) {
                const message = `Unexpected BOM in schema JSON buffer: ${bom}`;
                const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(schemaUri, message);
                context.addIssue(issue);
                return {
                    hasSchemaDefinition: true,
                    schema: undefined,
                };
            }
            const schemaString = schemaBuffer.toString();
            try {
                const resolvedSchema = JSON.parse(schemaString);
                return {
                    hasSchemaDefinition: true,
                    schema: resolvedSchema,
                };
            }
            catch (error) {
                //console.log(error);
                const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR("", "" + error);
                context.addIssue(issue);
                return {
                    hasSchemaDefinition: true,
                    schema: undefined,
                };
            }
        }
        return {
            hasSchemaDefinition: false,
            schema: undefined,
        };
    }
    /**
     * Validates the given `tileset.groups`
     *
     * @param groups - The groups
     * @param schema - The schema that was either contained in the
     * `tileset.schema`, or resolved from the `tileset.schemaUri`
     * @param context - The `ValidationContext`
     * @returns Whether the groups are valid
     */
    static validateTilesetGroups(groups, schema, context) {
        const groupsPath = "/groups";
        // The groups MUST be an array of objects
        if (!BasicValidator_1.BasicValidator.validateArray(groupsPath, "groups", groups, undefined, undefined, "object", context)) {
            return false;
        }
        // Validate each group against the schema
        let allValid = true;
        for (let index = 0; index < groups.length; index++) {
            const group = groups[index];
            const groupPath = groupsPath + "/" + index;
            allValid =
                allValid &&
                    MetadataEntityValidator_1.MetadataEntityValidator.validateMetadataEntity(groupPath, "group[" + index + "]", group, schema, context);
        }
        return allValid;
    }
}
exports.TilesetValidator = TilesetValidator;
