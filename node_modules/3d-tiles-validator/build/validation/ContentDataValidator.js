"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentDataValidator = void 0;
const path_1 = __importDefault(require("path"));
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
const _3d_tiles_tools_4 = require("3d-tiles-tools");
const ContentDataValidators_1 = require("./ContentDataValidators");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const ContentValidationIssues_1 = require("../issues/ContentValidationIssues");
const ValidationOptionChecks_1 = require("./ValidationOptionChecks");
/**
 * A class for validation of the data that is pointed to by a `content.uri`.
 *
 * @internal
 */
class ContentDataValidator {
    /**
     * Validate the actual data that is referred to by the URI in the
     * given content.
     *
     * This assumes that the given content has already been validated
     * to be structurally valid, using the `ContentValidator`.
     *
     * @param contentPath - The path for the `ValidationIssue` instances
     * @param content - The `Content` object
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateContentData(contentPath, content, context) {
        // Validate the uri
        const uri = content.uri;
        if (_3d_tiles_tools_2.Uris.isAbsoluteUri(uri)) {
            const path = contentPath;
            const message = `Tile content ${contentPath} refers to absolute URI ${uri}, ` +
                `which is not validated`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_WARNING(path, message);
            context.addIssue(issue);
            return true;
        }
        const result = await ContentDataValidator.validateContentDataInternal(contentPath, uri, context);
        return result;
    }
    /**
     * Perform the validation of the content data that is pointed to
     * by the given content URI.
     *
     * If the data causes validation issues, they will be summarized
     * into a `CONTENT_VALIDATION_ERROR` or `CONTENT_VALIDATION_WARNING`
     * that is added to the given context.
     *
     * If the data type cannot be determined, an `CONTENT_VALIDATION_WARNING`
     * will be added to the given context.
     *
     * @param contentPath - The path for the `ValidationIssue` instances.
     * @param contentUri - The URI of the content
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     */
    static async validateContentDataInternal(contentPath, contentUri, context) {
        const resourceResolver = context.getResourceResolver();
        //console.log('Validating ' +contentPath+" with "+contentUri);
        // Create the `ContentData` that summarizes all information
        // that is required for determining the content type
        const contentData = new _3d_tiles_tools_4.LazyContentData(contentUri, resourceResolver);
        // Make sure that the content data can be resolved at all
        const dataExists = await contentData.exists();
        if (!dataExists) {
            const path = contentPath;
            const message = `Tile content ${contentPath} refers to URI ${contentUri}, ` +
                `which could not be resolved`;
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_ERROR(path, message);
            context.addIssue(issue);
            return false;
        }
        // Check if the content data should be validated
        const options = context.getOptions();
        const shouldValidate = await ValidationOptionChecks_1.ValidationOptionChecks.shouldValidate(options, contentData);
        if (!shouldValidate) {
            return true;
        }
        // Find the validator for the content data
        const dataValidator = await ContentDataValidators_1.ContentDataValidators.findContentDataValidator(contentData);
        if (!(0, _3d_tiles_tools_1.defined)(dataValidator)) {
            const path = contentPath;
            const message = `Tile content ${contentPath} refers to URI ${contentUri}, ` +
                `for which no content type could be determined`;
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_WARNING(path, message);
            context.addIssue(issue);
            return true;
        }
        ContentDataValidator.trackExtensionsFound(contentData, context);
        const contentDataType = await _3d_tiles_tools_3.ContentDataTypeRegistry.findContentDataType(contentData);
        const isTileset = contentDataType === "CONTENT_TYPE_TILESET";
        // If the content is an external tileset, then add its
        // resolved URI to the context as an "activeTilesetUri",
        // to detect cycles
        const resolvedContentUri = context.resolveUri(contentUri);
        if (isTileset) {
            if (context.isActiveTilesetUri(resolvedContentUri)) {
                const message = `External tileset content ${contentUri} creates a cycle`;
                const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_ERROR(contentPath, message);
                context.addIssue(issue);
                return false;
            }
            context.addActiveTilesetUri(resolvedContentUri);
        }
        // Create a new context to collect the issues that are found in
        // the data. If there are issues, then they will be stored as
        // the 'causes' of a single content validation issue.
        const dirName = path_1.default.dirname(contentData.uri);
        const derivedContext = context.deriveFromUri(dirName);
        const result = await dataValidator.validateObject(contentUri, contentData, derivedContext);
        const derivedResult = derivedContext.getResult();
        if (isTileset) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.createForExternalTileset(contentUri, derivedResult);
            if (issue) {
                context.addIssue(issue);
            }
        }
        else {
            const issue = ContentValidationIssues_1.ContentValidationIssues.createForContent(contentUri, derivedResult);
            if (issue) {
                context.addIssue(issue);
            }
        }
        if (isTileset) {
            context.removeActiveTilesetUri(resolvedContentUri);
        }
        return result;
    }
    /**
     * Track the extensions that are used, and which only refer to
     * allowing certain content data types.
     *
     * When a certain content data type that requires an extension
     * is encountered, then the respective extension will be added
     * as a "found" extension to the given context.
     *
     * @param contentData - The `ContentData`
     * @param context - The `ValidationContext`
     */
    static async trackExtensionsFound(contentData, context) {
        const magic = await contentData.getMagic();
        const isGlb = magic.toString("ascii") === "glTF";
        if (isGlb) {
            context.addExtensionFound("3DTILES_content_gltf");
        }
        const contentDataType = await _3d_tiles_tools_3.ContentDataTypeRegistry.findContentDataType(contentData);
        const isGltf = contentDataType === "CONTENT_TYPE_GLTF";
        if (isGltf) {
            context.addExtensionFound("3DTILES_content_gltf");
        }
        const isProbably3tz = contentData.extension === ".3tz";
        if (isProbably3tz) {
            context.addExtensionFound("MAXAR_content_3tz");
        }
    }
}
exports.ContentDataValidator = ContentDataValidator;
