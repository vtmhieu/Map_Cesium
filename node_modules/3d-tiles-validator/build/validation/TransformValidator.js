"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformValidator = void 0;
const BasicValidator_1 = require("./BasicValidator");
const SemanticValidationIssues_1 = require("../issues/SemanticValidationIssues");
const cesium_1 = require("cesium");
const cesium_2 = require("cesium");
const cesium_3 = require("cesium");
/**
 * A class for validations related to `tile.transform` objects.
 *
 * @internal
 */
class TransformValidator {
    /**
     * Performs the validation to ensure that the given object is a
     * valid `transform` object.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param transform - The object to validate
     * @param context - The `ValidationContext` that any issues will be added to
     */
    static validateTransform(path, transform, context) {
        // The transform MUST be an array of 16 numbers
        if (!BasicValidator_1.BasicValidator.validateArray(path, "transform", transform, 16, 16, "number", context)) {
            return false;
        }
        const matrix = cesium_3.Matrix4.fromArray(transform);
        // Check whether the matrix is affine, which means that the
        // last row must be epsilon-equal to (0,0,0,1)
        const row3 = new cesium_1.Cartesian4();
        cesium_3.Matrix4.getRow(matrix, 3, row3);
        const isAffine = row3.equalsEpsilon(cesium_1.Cartesian4.UNIT_W, cesium_2.Math.EPSILON8);
        if (!isAffine) {
            const message = `The transform is not affine: [${transform}]`;
            const issue = SemanticValidationIssues_1.SemanticValidationIssues.TRANSFORM_INVALID(path, message);
            context.addIssue(issue);
            return false;
        }
        return true;
    }
}
exports.TransformValidator = TransformValidator;
TransformValidator.scratchMatrix4 = new cesium_3.Matrix4();
