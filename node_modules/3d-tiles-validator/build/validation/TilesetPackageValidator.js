"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetPackageValidator = void 0;
const path_1 = __importDefault(require("path"));
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
const Validators_1 = require("./Validators");
const _3d_tiles_tools_4 = require("3d-tiles-tools");
const ContentValidationIssues_1 = require("../issues/ContentValidationIssues");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const _3d_tiles_tools_5 = require("3d-tiles-tools");
const _3d_tiles_tools_6 = require("3d-tiles-tools");
const _3d_tiles_tools_7 = require("3d-tiles-tools");
const ArchiveValidation3tz_1 = require("../archives/ArchiveValidation3tz");
/**
 * An implementation of a validator that validates a `TilesetSource`.
 *
 * The actual validation function is `validatePackageFile`.
 *
 * This class also implements the `Validator` interface, so that
 * instances of it can be used when the tile content is a
 * tileset package. In this case, the validated type is `string`, where
 * this string is the 'resolvedUri' that points to a file in the
 * local file system.
 *
 * @internal
 */
class TilesetPackageValidator {
    /**
     * Implementation of the `Validator` interface. This validates
     * the given 'resolvedUri' string, assuming that it is a full
     * path to a tileset package in the local file system.
     *
     * @param uri - The (usually relative) URI of the package
     * @param resolvedUri - The resolved URI, which is the full URI
     * of the package in the local file system.
     * @param context - The `ValidationContext`
     * @returns A promise that is fulfilled when the validation is finished
     * and indicates whether the object was valid or not.
     */
    async validateObject(uri, resolvedUri, context) {
        //console.log("TilesetPackageValidator resolvedUri is " + resolvedUri);
        const isContent = true;
        const result = TilesetPackageValidator.validatePackageFileInternal(resolvedUri, isContent, context);
        return result;
    }
    /**
     * Validates the tileset that is contained in the package that is
     * pointed to by the given URI (assuming that it is a file in
     * the local file system).
     *
     * @param uri - The full URI of the package file
     * @param context - The `ValidationContext`
     * @returns A promise that indicates whether the package contained
     * a valid tileset.
     */
    static async validatePackageFile(uri, context) {
        const isContent = false;
        const result = TilesetPackageValidator.validatePackageFileInternal(uri, isContent, context);
        return result;
    }
    /**
     * Validates the tileset that is contained in the package that is
     * pointed to by the given URI (assuming that it is a file in
     * the local file system).
     *
     * @param uri - The full URI of the package file
     * @param isContent - Whether the given package was found as a tile
     * content. If this is the case, then the issues that are found
     * in the package will be summarized in a `CONTENT_VALIDATION_`
     * issue. Otherwise, they will be added directly to the given context.
     * @param context - The `ValidationContext`
     * @returns A promise that indicates whether the package contained
     * a valid tileset.
     */
    static async validatePackageFileInternal(uri, isContent, context) {
        // Create the tileset source for the package from the given URI
        // (i.e. the full package file name). If the source cannot
        // be opened, bail out with an IO_WARNING.
        let tilesetSource = undefined;
        const extension = path_1.default.extname(uri).toLowerCase();
        if (extension === ".3tz") {
            tilesetSource = new _3d_tiles_tools_5.TilesetSource3tz();
        }
        else if (extension === ".3dtiles") {
            tilesetSource = new _3d_tiles_tools_6.TilesetSource3dtiles();
        }
        else if (extension === "") {
            tilesetSource = new _3d_tiles_tools_7.TilesetSourceFs();
        }
        else {
            const message = `Could not create tileset source from ${uri}: No known file extension. `;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_WARNING(uri, message);
            context.addIssue(issue);
            return true;
        }
        tilesetSource.open(uri);
        const result = await TilesetPackageValidator.validatePackageInternal(uri, tilesetSource, isContent, context);
        tilesetSource.close();
        return result;
    }
    /**
     * Validates the tileset that is contained in the given `TilesetSource`.
     *
     * The caller is responsible for calling 'open' on the source before
     * passing it to this method, and 'close' after this method returns.
     *
     * @param uri - The full URI of the package file
     * @param tilesetSource - The `TilesetSource` that was created from
     * the package file
     * @param isContent - Whether the given package was found as a tile
     * content. If this is the case, then the issues that are found
     * in the package will be summarized in a `CONTENT_VALIDATION_`
     * issue. Otherwise, they will be added directly to the given context.
     * @param context - The `ValidationContext`
     * @returns A promise that indicates whether the package contained
     * a valid tileset.
     */
    static async validatePackageInternal(uri, tilesetSource, isContent, context) {
        // If the package is a 3TZ package, then perform the extended
        // validation of the 3TZ index part, using the ("legacy") 3TZ
        // package validation
        if (tilesetSource instanceof _3d_tiles_tools_5.TilesetSource3tz) {
            const tilesetSource3tz = tilesetSource;
            const zipIndex = tilesetSource3tz.getZipIndex();
            if ((0, _3d_tiles_tools_1.defined)(zipIndex)) {
                try {
                    const indexValid = await ArchiveValidation3tz_1.ArchiveValidation3tz.validateIndex(zipIndex, uri, false);
                    if (!indexValid) {
                        const message = `The 3TZ index is not valid`;
                        const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_ERROR(uri, message);
                        context.addIssue(issue);
                        return false;
                    }
                }
                catch (error) {
                    const message = `Error while validating 3TZ index: ${error}.`;
                    const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_VALIDATION_ERROR(uri, message);
                    context.addIssue(issue);
                    return false;
                }
            }
        }
        // Create the `TilesetSourceResourceResolver` from the package,
        // and obtain the data for the `tileset.json` file.
        // This has to be present according to the 3TZ specification.
        const plainPackageResourceResolver = new _3d_tiles_tools_4.TilesetSourceResourceResolver("./", tilesetSource);
        const packageResourceResolver = new _3d_tiles_tools_3.UnzippingResourceResolver(plainPackageResourceResolver);
        const tilesetJsonBuffer = await packageResourceResolver.resolveData("tileset.json");
        if (!(0, _3d_tiles_tools_1.defined)(tilesetJsonBuffer)) {
            const message = `Could not read 'tileset.json' from package ${uri}.`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(uri, message);
            context.addIssue(issue);
            return false;
        }
        const bom = _3d_tiles_tools_2.Buffers.getUnicodeBOMDescription(tilesetJsonBuffer);
        if ((0, _3d_tiles_tools_1.defined)(bom)) {
            const message = `Unexpected BOM in subtree JSON buffer: ${bom}`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(uri, message);
            context.addIssue(issue);
            return false;
        }
        // Parse the tileset object from the JSON data
        let tileset = undefined;
        try {
            tileset = JSON.parse(tilesetJsonBuffer.toString());
        }
        catch (error) {
            const message = `Could not parse tileset JSON from 'tileset.json' ` +
                `data in package ${uri}.`;
            const issue = IoValidationIssue_1.IoValidationIssues.IO_ERROR(uri, message);
            context.addIssue(issue);
            return false;
        }
        // Open a new context for collecting the issues that
        // are caused by the tileset, and validate the
        // tileset using a default tileset validator.
        const derivedContext = context.deriveFromResourceResolver(uri, packageResourceResolver);
        const tilesetValidator = Validators_1.Validators.createDefaultTilesetValidator();
        const result = await tilesetValidator.validateObject(uri + "/tileset.json", tileset, derivedContext);
        const derivedResult = derivedContext.getResult();
        if (isContent) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.createForContent(uri, derivedResult);
            if (issue) {
                context.addIssue(issue);
            }
        }
        else {
            for (const innerIssue of derivedResult.issues) {
                context.addIssue(innerIssue);
            }
        }
        return result;
    }
}
exports.TilesetPackageValidator = TilesetPackageValidator;
