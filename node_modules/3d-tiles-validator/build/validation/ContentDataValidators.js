"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentDataValidators = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const Validators_1 = require("./Validators");
const TilesetPackageValidator_1 = require("./TilesetPackageValidator");
const B3dmValidator_1 = require("../tileFormats/B3dmValidator");
const I3dmValidator_1 = require("../tileFormats/I3dmValidator");
const PntsValidator_1 = require("../tileFormats/PntsValidator");
const CmptValidator_1 = require("../tileFormats/CmptValidator");
const GltfValidator_1 = require("../tileFormats/GltfValidator");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
/**
 * A class for managing `Validator` instances that are used for
 * validating the data that is pointed to by a `content.uri`.
 *
 * The only public method (for now) is `findContentDataValidator`,
 * which returns the validator that should be used for a given
 * `ContentData` object.
 *
 * @internal
 */
class ContentDataValidators {
    /**
     * Registers all default content data validators
     */
    static registerDefaults() {
        if (ContentDataValidators._registeredDefaults) {
            return;
        }
        // The keys that are used here are the strings that are
        // returned by the `ContentDataTypeRegistry`, for a
        // given `ContentData`.
        // THESE STRINGS ARE NOT SPECIFIED.
        // Using them here is relying on an implementation
        // detail. Whether or not these strings should be
        // public and/or specified has to be decided.
        ContentDataValidators.registerForBuffer("CONTENT_TYPE_GLB", new GltfValidator_1.GltfValidator());
        ContentDataValidators.registerForBuffer("CONTENT_TYPE_B3DM", new B3dmValidator_1.B3dmValidator());
        ContentDataValidators.registerForBuffer("CONTENT_TYPE_I3DM", new I3dmValidator_1.I3dmValidator());
        ContentDataValidators.registerForBuffer("CONTENT_TYPE_CMPT", new CmptValidator_1.CmptValidator());
        ContentDataValidators.registerForBuffer("CONTENT_TYPE_PNTS", new PntsValidator_1.PntsValidator());
        // Certain content types are known to be encountered,
        // but are not (yet) validated. These can either be
        // ignored, or cause a warning. In the future, this
        // should be configurable, probably even on a per-type
        // basis, via the command line or a config file
        const ignoreUnhandledContentTypes = false;
        let geomValidator = Validators_1.Validators.createEmptyValidator();
        let vctrValidator = Validators_1.Validators.createEmptyValidator();
        let geojsonValidator = Validators_1.Validators.createEmptyValidator();
        if (!ignoreUnhandledContentTypes) {
            geomValidator = Validators_1.Validators.createContentValidationWarning("Skipping 'geom' validation");
            vctrValidator = Validators_1.Validators.createContentValidationWarning("Skipping 'vctr' validation");
            geojsonValidator = Validators_1.Validators.createContentValidationWarning("Skipping 'geojson' validation");
        }
        ContentDataValidators.register("CONTENT_TYPE_GEOM", geomValidator);
        ContentDataValidators.register("CONTENT_TYPE_VCTR", vctrValidator);
        ContentDataValidators.register("CONTENT_TYPE_GEOJSON", geojsonValidator);
        ContentDataValidators.register("CONTENT_TYPE_3TZ", ContentDataValidators.createPackageValidator());
        ContentDataValidators.register("CONTENT_TYPE_TILESET", ContentDataValidators.createTilesetValidator());
        ContentDataValidators.register("CONTENT_TYPE_GLTF", ContentDataValidators.createGltfJsonValidator());
        ContentDataValidators._registeredDefaults = true;
    }
    /**
     * Creates a validator for content data that refers to a 3TZ package.
     *
     * This takes the contentData.uri, resolves it (to obtain an absolute URI),
     * and assumes that this URI is a path in the local file system, which
     * is then passed to the `TilesetPackageValidator`
     *
     * @returns The validator
     */
    static createPackageValidator() {
        const packageValidator = new TilesetPackageValidator_1.TilesetPackageValidator();
        const validator = {
            async validateObject(inputPath, input, context) {
                const resolvedUri = context.resolveUri(input.uri);
                const result = await packageValidator.validateObject(inputPath, resolvedUri, context);
                return result;
            },
        };
        return validator;
    }
    /**
     * Creates a validator for content data that represents an external tileset.
     *
     * This validator will parse the JSON from the content data buffer, and
     * pass it to a default tileset validator.
     *
     * @returns The validator
     */
    static createTilesetValidator() {
        const externalValidator = Validators_1.Validators.createDefaultTilesetValidator();
        const bufferValidator = Validators_1.Validators.parseFromBuffer(externalValidator);
        const contentDataValidator = ContentDataValidators.wrapBufferValidator(bufferValidator);
        return contentDataValidator;
    }
    /**
     * Creates a validator for content data that represents glTF JSON data.
     *
     * This validator will pass the buffer with the JSON data to the
     * standard glTF validator.
     *
     * @returns The validator
     */
    static createGltfJsonValidator() {
        const bufferValidator = new GltfValidator_1.GltfValidator();
        const contentDataValidator = ContentDataValidators.wrapBufferValidator(bufferValidator);
        return contentDataValidator;
    }
    /**
     * Tries to find a data validator that can be used for validating
     * the given content data. If no matching validator can be found,
     * then `undefined` is returned.
     *
     * @param contentData - The `ContentData`
     * @returns The validator, or `undefined`
     */
    static async findContentDataValidator(contentData) {
        ContentDataValidators.registerDefaults();
        const contentDataTypeName = await _3d_tiles_tools_1.ContentDataTypeRegistry.findContentDataType(contentData);
        if (!contentDataTypeName) {
            return undefined;
        }
        const dataValidator = ContentDataValidators.dataValidators[contentDataTypeName];
        return dataValidator;
    }
    /**
     * Wraps the given validator for `Buffer` objects into one that
     * can be applied to `ContentData` objects, and just applies
     * the given validator to the buffer that is returned by
     * `ContentData#getData`.
     *
     * @param bufferValidator - The validator for `Buffer` objects
     * @returns The validator for `ContentData` objects
     */
    static wrapBufferValidator(bufferValidator) {
        return {
            async validateObject(inputPath, input, context) {
                const data = await input.getData();
                if (!(0, _3d_tiles_tools_1.defined)(data)) {
                    const message = `Could not resolve ${input.uri}`;
                    const issue = IoValidationIssue_1.IoValidationIssues.IO_WARNING(inputPath, message);
                    context.addIssue(issue);
                    return true;
                }
                const result = await bufferValidator.validateObject(inputPath, data, context);
                return result;
            },
        };
    }
    /**
     * Register a validator that should be used for the content
     * data buffer, when the content data has the type that is
     * indicated by the given name.
     *
     * @param contentDataTypeName - The content data type name
     * @param bufferValidator - The validator for the buffer data
     */
    static registerForBuffer(contentDataTypeName, bufferValidator) {
        ContentDataValidators.register(contentDataTypeName, ContentDataValidators.wrapBufferValidator(bufferValidator));
    }
    /**
     * Registers a data validator that will be used when a
     * `ContentData` has the type that is indicated by the
     * given name.
     *
     * @param contentDataTypeName - The content data type name
     * @param dataValidator - The data validator
     */
    static register(contentDataTypeName, dataValidator) {
        ContentDataValidators.dataValidators[contentDataTypeName] = dataValidator;
    }
}
exports.ContentDataValidators = ContentDataValidators;
/**
 * The validators that have been registered.
 *
 * See `registerDefaults` for details.
 */
ContentDataValidators.dataValidators = {};
/**
 * Whether the default content data validators have already
 * been registered by calling 'registerDefaults'
 *
 * Note: This could be solved with a static initializer block, but the
 * unclear initialization order of the classes would make this brittle
 */
ContentDataValidators._registeredDefaults = false;
