"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoundingVolumeS2Validator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const BasicValidator_1 = require("../BasicValidator");
const BoundingVolumeValidator_1 = require("../BoundingVolumeValidator");
const RootPropertyValidator_1 = require("../RootPropertyValidator");
const ExtendedObjectsValidators_1 = require("../ExtendedObjectsValidators");
const SemanticValidationIssues_1 = require("../../issues/SemanticValidationIssues");
const BoundingVolumeS2ValidationIssues_1 = require("./BoundingVolumeS2ValidationIssues");
/**
 * A class for the validation of bounding volumes that contain
 * `3DTILES_bounding_volume_S2` extension objects
 *
 * @internal
 */
class BoundingVolumeS2Validator {
    /**
     * Performs the validation of a `BoundungVolume` object that
     * contains a `3DTILES_bounding_volume_S2` extension object.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param boundingVolume - The object to validate
     * @param context - The `ValidationContext` that any issues will be added to
     * @returns Whether the object was valid
     */
    async validateObject(path, boundingVolume, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(path, "boundingVolume", boundingVolume, context)) {
            return false;
        }
        let result = true;
        // Validate the box
        const box = boundingVolume.box;
        const boxPath = path + "/box";
        if ((0, _3d_tiles_tools_1.defined)(box)) {
            if (!BoundingVolumeValidator_1.BoundingVolumeValidator.validateBoundingBox(boxPath, box, context)) {
                result = false;
            }
        }
        // Validate the region
        const region = boundingVolume.region;
        const regionPath = path + "/region";
        if ((0, _3d_tiles_tools_1.defined)(region)) {
            if (!BoundingVolumeValidator_1.BoundingVolumeValidator.validateBoundingRegion(regionPath, region, context)) {
                result = false;
            }
        }
        // Validate the sphere
        const sphere = boundingVolume.sphere;
        const spherePath = path + "/sphere";
        if ((0, _3d_tiles_tools_1.defined)(sphere)) {
            if (!BoundingVolumeValidator_1.BoundingVolumeValidator.validateBoundingSphere(spherePath, sphere, context)) {
                result = false;
            }
        }
        // If there is a 3DTILES_bounding_volume_S2 extension,
        // perform the validation of the corresponding object
        const extensions = boundingVolume.extensions;
        if ((0, _3d_tiles_tools_1.defined)(extensions)) {
            const key = "3DTILES_bounding_volume_S2";
            const s2 = extensions[key];
            const s2Path = path + "/" + key;
            if (!BoundingVolumeS2Validator.validateBoundingVolumeS2(s2Path, s2, context)) {
                result = false;
            }
        }
        return result;
    }
    /**
     * Performs the validation to ensure that the given object is a
     * valid `3DTILES_bounding_volume_S2` object.
     *
     * @param path - The path for `ValidationIssue` instances
     * @param object - The object to validate
     * @param context - The `ValidationContext` that any issues will be added to
     * @returns Whether the object was valid
     */
    static validateBoundingVolumeS2(path, object, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(path, "object", object, context)) {
            return false;
        }
        let result = true;
        // Validate the object as a RootProperty
        if (!RootPropertyValidator_1.RootPropertyValidator.validateRootProperty(path, "3DTILES_bounding_volume_S2", object, context)) {
            result = false;
        }
        // Perform the validation of the object in view of the
        // extensions that it may contain
        if (!ExtendedObjectsValidators_1.ExtendedObjectsValidators.validateExtendedObject(path, object, context)) {
            result = false;
        }
        // If there was an extension validator that overrides the
        // default validation, then skip the remaining validation.
        if (ExtendedObjectsValidators_1.ExtendedObjectsValidators.hasOverride(object)) {
            return result;
        }
        // Validate the token
        const token = object.token;
        const tokenPath = path + "/token";
        // The token MUST be defined
        // The token MUST be a string
        if (!BasicValidator_1.BasicValidator.validateString(tokenPath, "token", token, context)) {
            result = false;
        }
        else {
            // The token MUST be a valid S2 token
            if (!BoundingVolumeS2Validator.isValidToken(token)) {
                const message = `The S2 token '${token}' is not valid`;
                const issue = BoundingVolumeS2ValidationIssues_1.BoundingVolumeS2ValidationIssues.S2_TOKEN_INVALID(tokenPath, message);
                context.addIssue(issue);
                result = false;
            }
        }
        // Validate the minimumHeight
        const minimumHeight = object.minimumHeight;
        const minimumHeightPath = path + "/minimumHeight";
        // The minimumHeight MUST be a number
        if (!BasicValidator_1.BasicValidator.validateNumber(minimumHeightPath, "minimumHeight", minimumHeight, context)) {
            result = false;
        }
        // Validate the maximumHeight
        const maximumHeight = object.maximumHeight;
        const maximumHeightPath = path + "/maximumHeight";
        // The maximumHeight MUST be a number
        if (!BasicValidator_1.BasicValidator.validateNumber(maximumHeightPath, "maximumHeight", maximumHeight, context)) {
            result = false;
        }
        // The minimumHeight MUST NOT be larger
        // than the maximumHeight
        if ((0, _3d_tiles_tools_1.defined)(minimumHeight) && (0, _3d_tiles_tools_1.defined)(maximumHeight)) {
            if (minimumHeight > maximumHeight) {
                const message = `The minimumHeight may not be larger than the ` +
                    `maximumHeight, but the minimumHeight is ${minimumHeight} ` +
                    `and the maximum height is ${maximumHeight}`;
                const issue = SemanticValidationIssues_1.SemanticValidationIssues.BOUNDING_VOLUME_INVALID(path, message);
                context.addIssue(issue);
                result = false;
            }
        }
        return result;
    }
    /**
     * Peforms a basic validation that the given string is a valid S2 cell token
     *
     * @param token - The token
     * @returns Whether the token is valid
     */
    static isValidToken(token) {
        // According to cesium/Source/Core/S2Cell.js
        if (!/^[0-9a-fA-F]{1,16}$/.test(token)) {
            return false;
        }
        // Further constraints could be added here (e.g. that
        // the first digit is only a value in [0,5] ...)
        return true;
    }
}
exports.BoundingVolumeS2Validator = BoundingVolumeS2Validator;
