"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const BasicValidator_1 = require("./../BasicValidator");
const RootPropertyValidator_1 = require("./../RootPropertyValidator");
const ExtendedObjectsValidators_1 = require("./../ExtendedObjectsValidators");
const MetadataClassValidator_1 = require("./MetadataClassValidator");
const MetadataEnumValidator_1 = require("./MetadataEnumValidator");
const IoValidationIssue_1 = require("../../issues/IoValidationIssue");
/**
 * A class for validations related to `schema` objects.
 *
 * @internal
 */
class SchemaValidator {
    /**
     * Performs the validation of the schema that is parsed from the
     * given input string.
     *
     * @param input - The string that was read from a schema JSON file
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     * and indicates whether the object was valid or not.
     */
    async validateJsonString(input, context) {
        try {
            const object = JSON.parse(input);
            const result = await this.validateObject("", object, context);
            return result;
        }
        catch (error) {
            //console.log(error);
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR("", "" + error);
            context.addIssue(issue);
            return false;
        }
    }
    /**
     * Implementation of the `Validator` interface that just passes the
     * input to `validateSchema`.
     *
     * @param input - The `Schema` object
     * @param context - The `ValidationContext`
     * @returns A promise that resolves when the validation is finished
     * and indicates whether the object was valid or not.
     */
    async validateObject(path, input, context) {
        return SchemaValidator.validateSchema(path, input, context);
    }
    /**
     * Performs the validation of the given `Schema` object that was parsed
     * from a schema JSON input.
     *
     * Issues that are encountered during the validation will be added
     * as `ValidationIssue` instances to the given `ValidationContext`.
     *
     * @param path - The path for the given object. This may either
     * be `"/schema"` (for a `tileset.schema`), or the empty string
     * (for a schema that was read from a standalone schema file).
     * @param schema - The `Schema` object
     * @param context - The `ValidationContext`
     */
    static validateSchema(path, schema, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(path, "schema", schema, context)) {
            return false;
        }
        let result = true;
        // Validate the object as a RootProperty
        if (!RootPropertyValidator_1.RootPropertyValidator.validateRootProperty(path, "schema", schema, context)) {
            result = false;
        }
        // Perform the validation of the object in view of the
        // extensions that it may contain
        if (!ExtendedObjectsValidators_1.ExtendedObjectsValidators.validateExtendedObject(path, schema, context)) {
            result = false;
        }
        // If there was an extension validator that overrides the
        // default validation, then skip the remaining validation.
        if (ExtendedObjectsValidators_1.ExtendedObjectsValidators.hasOverride(schema)) {
            return result;
        }
        // Validate the id
        const id = schema.id;
        const idPath = path + "/id";
        // The id MUST be defined
        // The id MUST be a string
        // The id MUST be a valid identifier
        if (!BasicValidator_1.BasicValidator.validateIdentifierString(idPath, "id", id, context)) {
            result = false;
        }
        // Validate the name
        // If the name is defined, it MUST be a string
        if (!BasicValidator_1.BasicValidator.validateOptionalString(path, schema, "name", context)) {
            result = false;
        }
        // Validate the description
        // If the description is defined, it MUST be a string
        if (!BasicValidator_1.BasicValidator.validateOptionalString(path, schema, "description", context)) {
            result = false;
        }
        // Validate the version
        // If the version is defined, it MUST be a string
        if (!BasicValidator_1.BasicValidator.validateOptionalString(path, schema, "version", context)) {
            result = false;
        }
        // Validate the classes
        const classes = schema.classes;
        const classesPath = path + "/classes";
        if ((0, _3d_tiles_tools_1.defined)(classes)) {
            // The classes MUST be an object
            if (!BasicValidator_1.BasicValidator.validateObject(classesPath, "classes", classes, context)) {
                result = false;
            }
            else {
                for (const [className, metadataClass] of Object.entries(classes)) {
                    const metadataClassPath = classesPath + "/" + className;
                    // Each class name name MUST match the ID regex
                    if (!BasicValidator_1.BasicValidator.validateIdentifierString(metadataClassPath, className, className, context)) {
                        result = false;
                    }
                    if (!MetadataClassValidator_1.MetadataClassValidator.validateMetadataClass(metadataClassPath, className, metadataClass, schema, context)) {
                        result = false;
                    }
                }
            }
        }
        // Validate the enums
        const enums = schema.enums;
        const enumsPath = path + "/enums";
        if ((0, _3d_tiles_tools_1.defined)(enums)) {
            // The enums MUST be an object
            if (!BasicValidator_1.BasicValidator.validateObject(enumsPath, "enums", enums, context)) {
                result = false;
            }
            else {
                for (const [enumName, metadataEnum] of Object.entries(enums)) {
                    const metadataEnumPath = enumsPath + "/" + enumName;
                    // Each enum name name MUST match the ID regex
                    if (!BasicValidator_1.BasicValidator.validateIdentifierString(metadataEnumPath, enumName, enumName, context)) {
                        result = false;
                    }
                    if (!MetadataEnumValidator_1.MetadataEnumValidator.validateMetadataEnum(metadataEnumPath, enumName, metadataEnum, context)) {
                        result = false;
                    }
                }
            }
        }
        return result;
    }
}
exports.SchemaValidator = SchemaValidator;
