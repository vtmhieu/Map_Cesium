"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataClassValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const BasicValidator_1 = require("../BasicValidator");
const RootPropertyValidator_1 = require("../RootPropertyValidator");
const ExtendedObjectsValidators_1 = require("../ExtendedObjectsValidators");
const ClassPropertyValidator_1 = require("./ClassPropertyValidator");
const ClassPropertySemanticsValidator_1 = require("./ClassPropertySemanticsValidator");
/**
 * A class for validations related to `MetadataClass` objects.
 *
 * @internal
 */
class MetadataClassValidator {
    /**
     * Validate the given `MetadataClass` object
     *
     * @param metadataClassPath - The path for `ValidationIssue` instances
     * @param name - The name of the class
     * @param metadataClass - The actual `MetadataClass`
     * @param schema - The `Schema`
     * @param context - The `ValidatonContext`
     * @returns Whether the object was valid
     */
    static validateMetadataClass(metadataClassPath, name, metadataClass, schema, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(metadataClassPath, name, metadataClass, context)) {
            return false;
        }
        let result = true;
        // Validate the object as a RootProperty
        if (!RootPropertyValidator_1.RootPropertyValidator.validateRootProperty(metadataClassPath, name, metadataClass, context)) {
            result = false;
        }
        // Perform the validation of the object in view of the
        // extensions that it may contain
        if (!ExtendedObjectsValidators_1.ExtendedObjectsValidators.validateExtendedObject(metadataClassPath, metadataClass, context)) {
            result = false;
        }
        // If there was an extension validator that overrides the
        // default validation, then skip the remaining validation.
        if (ExtendedObjectsValidators_1.ExtendedObjectsValidators.hasOverride(metadataClass)) {
            return result;
        }
        // Validate the name.
        // If the name is defined, it MUST be a string.
        if (!BasicValidator_1.BasicValidator.validateOptionalString(metadataClassPath, metadataClass, "name", context)) {
            result = false;
        }
        // Validate the description.
        // If the description is defined, it MUST be a string.
        if (!BasicValidator_1.BasicValidator.validateOptionalString(metadataClassPath, metadataClass, "description", context)) {
            result = false;
        }
        // Validate the properties
        const properties = metadataClass.properties;
        const propertiesPath = metadataClassPath + "/properties";
        if ((0, _3d_tiles_tools_1.defined)(properties)) {
            // The properties MUST have at least 1 property
            if (!BasicValidator_1.BasicValidator.validateNumberOfProperties(propertiesPath, "properties", properties, 1, undefined, context)) {
                result = false;
            }
            // Validate each property
            let allPropertiesValid = true;
            for (const propertyName of Object.keys(properties)) {
                const property = properties[propertyName];
                const propertyPath = propertiesPath + "/" + propertyName;
                // Each property name MUST match the ID regex
                if (!BasicValidator_1.BasicValidator.validateIdentifierString(propertyPath, propertyName, propertyName, context)) {
                    allPropertiesValid = false;
                    result = false;
                }
                if (!ClassPropertyValidator_1.ClassPropertyValidator.validateClassProperty(schema, propertyPath, propertyName, property, context)) {
                    allPropertiesValid = false;
                    result = false;
                }
            }
            // If all properties are valid, validate the semantics of all
            // properties, i.e. their uniqueness, and compliance to the
            // semantic definitions
            if (allPropertiesValid) {
                if (!ClassPropertySemanticsValidator_1.ClassPropertySemanticsValidator.validateSemantics(metadataClassPath, properties, context)) {
                    result = false;
                }
            }
        }
        return result;
    }
}
exports.MetadataClassValidator = MetadataClassValidator;
