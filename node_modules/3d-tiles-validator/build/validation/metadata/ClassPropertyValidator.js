"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassPropertyValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const BasicValidator_1 = require("./../BasicValidator");
const MetadataValueValidator_1 = require("./MetadataValueValidator");
const ClassPropertyValueValidator_1 = require("./ClassPropertyValueValidator");
const _3d_tiles_tools_3 = require("3d-tiles-tools");
const _3d_tiles_tools_4 = require("3d-tiles-tools");
const JsonValidationIssues_1 = require("../../issues/JsonValidationIssues");
const MetadataValidationIssues_1 = require("../../issues/MetadataValidationIssues");
/**
 * A class for validations related to `class.property` objects.
 *
 * @internal
 */
class ClassPropertyValidator {
    /**
     * Validates that the given object is a valid `class.property` object.
     *
     * @param schema - The `Schema`
     * @param propertyPath - The path for the `ValidationIssue` instances
     * @param propertyName - The name of the property
     * @param property - The property
     * @param context - The `ValidationContext`
     * @returns Whether the object was valid
     */
    static validateClassProperty(schema, propertyPath, propertyName, property, context) {
        // Make sure that the given value is an object
        if (!BasicValidator_1.BasicValidator.validateObject(propertyPath, propertyName, property, context)) {
            return false;
        }
        return ClassPropertyValidator.validateClassPropertyInternal(schema, propertyPath, propertyName, property, context);
    }
    /**
     * Internal method for `validateClassProperty` that just
     * assumes that the property is defined and an `"object"`.
     *
     * @param schema - The `Schema`
     * @param propertyPath - The path for the `ValidationIssue` instances
     * @param propertyName - The name of the property
     * @param property - The property
     * @param context - The `ValidationContext`
     * @returns Whether the object was valid
     */
    static validateClassPropertyInternal(schema, propertyPath, propertyName, property, context) {
        let result = true;
        // Validate the name.
        // If the name is defined, it MUST be a string.
        if (!BasicValidator_1.BasicValidator.validateOptionalString(propertyPath, property, "name", context)) {
            result = false;
        }
        // Validate the description.
        // If the description is defined, it MUST be a string.
        if (!BasicValidator_1.BasicValidator.validateOptionalString(propertyPath, property, "description", context)) {
            result = false;
        }
        // Validate the type
        // The type MUST be defined
        // The type MUST be a string
        const type = property.type;
        const typePath = propertyPath + "/type";
        if (!BasicValidator_1.BasicValidator.validateString(typePath, "type", type, context)) {
            result = false;
        }
        else {
            // The type MUST be one of the allowed types
            if (!BasicValidator_1.BasicValidator.validateEnum(typePath, "type", type, _3d_tiles_tools_3.MetadataTypes.allTypes, context)) {
                result = false;
            }
        }
        // Validate the componentType
        const componentType = property.componentType;
        const componentTypePath = propertyPath + "/componentType";
        const isNumericType = _3d_tiles_tools_3.MetadataTypes.isNumericType(type);
        if (isNumericType && !(0, _3d_tiles_tools_1.defined)(componentType)) {
            // For numeric types (SCALAR, VECn, or MATn) the
            // componentType MUST be defined
            if (isNumericType) {
                const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_COMPONENT_TYPE_MISSING(componentTypePath, type);
                context.addIssue(issue);
                result = false;
            }
        }
        if (!isNumericType && (0, _3d_tiles_tools_1.defined)(componentType)) {
            // For non-numeric types the componentType MUST NOT be defined
            const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_COMPONENT_TYPE_FOR_NON_NUMERIC_TYPE(componentTypePath, componentType, type);
            context.addIssue(issue);
            result = false;
        }
        else if ((0, _3d_tiles_tools_1.defined)(componentType)) {
            // The componentType MUST be a string
            if (!BasicValidator_1.BasicValidator.validateString(componentTypePath, "componentType", componentType, context)) {
                result = false;
            }
            else {
                // The componentType MUST be one of the allowed types
                if (!BasicValidator_1.BasicValidator.validateEnum(componentTypePath, "componentType", componentType, _3d_tiles_tools_4.MetadataComponentTypes.allComponentTypes, context)) {
                    result = false;
                }
            }
        }
        // Validate the enumType
        const enumType = property.enumType;
        const enumTypePath = propertyPath + "/enumType";
        // When the type is "ENUM", then the enumType MUST be defined
        if (type === "ENUM" && !(0, _3d_tiles_tools_1.defined)(enumType)) {
            const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_ENUM_TYPE_WITHOUT_ENUMTYPE(propertyPath);
            context.addIssue(issue);
            result = false;
        }
        else if (type !== "ENUM" && (0, _3d_tiles_tools_1.defined)(enumType)) {
            // When the type is not "ENUM", then the enumType MUST NOT be defined
            const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_ENUMTYPE_WITH_NON_ENUM_TYPE(enumTypePath, enumType, type);
            context.addIssue(issue);
            result = false;
        }
        else if ((0, _3d_tiles_tools_1.defined)(enumType)) {
            // The enumType MUST be a string
            if (!BasicValidator_1.BasicValidator.validateString(enumTypePath, "enumType", enumType, context)) {
                result = false;
            }
            else {
                // When the enumType is defined, then the schema MUST
                // define an enum with this name
                const enums = (0, _3d_tiles_tools_2.defaultValue)(schema.enums, {});
                if (!Object.keys(enums).includes(enumType)) {
                    const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_ENUMTYPE_NOT_FOUND(propertyPath, enumType);
                    context.addIssue(issue);
                    result = false;
                }
            }
        }
        // Validate the 'array' property
        const array = property.array;
        const arrayPath = propertyPath + "/array";
        if ((0, _3d_tiles_tools_1.defined)(array)) {
            // The array MUST be a boolean
            if (!BasicValidator_1.BasicValidator.validateBoolean(arrayPath, "array", array, context)) {
                result = false;
            }
        }
        // Validate the count
        const count = property.count;
        const countPath = propertyPath + "/count";
        if ((0, _3d_tiles_tools_1.defined)(count)) {
            // The count MUST be an integer
            // The count MUST be at least 2
            if (!BasicValidator_1.BasicValidator.validateIntegerRange(countPath, "count", count, 2, true, undefined, false, context)) {
                result = false;
            }
            // When the count is defined, then the property MUST be an array
            if (!array) {
                const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_COUNT_FOR_NON_ARRAY(propertyPath, propertyName);
                context.addIssue(issue);
                result = false;
            }
        }
        // Validate the 'normalized' property
        const normalized = property.normalized;
        const normalizedPath = propertyPath + "/normalized";
        if ((0, _3d_tiles_tools_1.defined)(normalized)) {
            // The normalized MUST be a boolean
            if (!BasicValidator_1.BasicValidator.validateBoolean(normalizedPath, "normalized", normalized, context)) {
                result = false;
            }
            if (normalized) {
                // If normalized is 'true', then the type MUST be one
                // of the numeric types (SCALAR, VECn, MATn)
                if (!_3d_tiles_tools_3.MetadataTypes.isNumericType(type)) {
                    const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_NORMALIZED_FOR_NON_NORMALIZABLE_TYPE(propertyPath, propertyName, type);
                    context.addIssue(issue);
                    result = false;
                }
                if ((0, _3d_tiles_tools_1.defined)(componentType)) {
                    // If normalized is 'true', then the componentType (if present)
                    // MUST be an integer type
                    if (!_3d_tiles_tools_4.MetadataComponentTypes.isIntegerComponentType(componentType)) {
                        const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_NORMALIZED_FOR_NON_INTEGER_COMPONENT_TYPE(propertyPath, propertyName, componentType);
                        context.addIssue(issue);
                        result = false;
                    }
                }
            }
        }
        // Validate the 'required' property
        const required = property.required;
        const requiredPath = propertyPath + "/required";
        if ((0, _3d_tiles_tools_1.defined)(required)) {
            // The required MUST be a boolean
            if (!BasicValidator_1.BasicValidator.validateBoolean(requiredPath, "required", required, context)) {
                result = false;
            }
        }
        // Validate the 'noData' property
        const noData = property.noData;
        const noDataPath = propertyPath + "/noData";
        if ((0, _3d_tiles_tools_1.defined)(noData)) {
            if (required) {
                // The noData value MUST not be given for 'required' properties
                const message = `The property '${propertyName}' defines a 'noData' ` +
                    `value, but is 'required'`;
                const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_INCONSISTENT(noDataPath, message);
                context.addIssue(issue);
                result = false;
            }
            else if (type === "BOOLEAN") {
                // The noData value MUST not be given for BOOLEAN types
                const message = `The property '${propertyName}' defines a 'noData' ` +
                    `value, but has the type 'BOOLEAN'`;
                const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_INCONSISTENT(noDataPath, message);
                context.addIssue(issue);
                result = false;
            }
        }
        // Validate the 'default' property
        const theDefault = property.default;
        const defaultPath = propertyPath + "/default";
        if ((0, _3d_tiles_tools_1.defined)(theDefault)) {
            if (required) {
                // The default value MUST not be given for 'required' properties
                const message = `The property '${propertyName}' defines a 'default' ` +
                    `value, but is 'required'`;
                const issue = MetadataValidationIssues_1.MetadataValidationIssues.CLASS_PROPERTY_INCONSISTENT(defaultPath, message);
                context.addIssue(issue);
                result = false;
            }
        }
        // Validate the semantic
        const semantic = property.semantic;
        const semanticPath = propertyPath + "/semantic";
        if ((0, _3d_tiles_tools_1.defined)(semantic)) {
            // The semantic MUST be a string
            if (!BasicValidator_1.BasicValidator.validateString(semanticPath, "semantic", semantic, context)) {
                result = false;
            }
            else {
                // The semantic string MUST have a length of at least 1
                const minLength = 1;
                if (semantic.length < minLength) {
                    const message = `The 'semantic' must have a length of least ${minLength}, ` +
                        `but has a length of ${semantic.length}`;
                    const issue = JsonValidationIssues_1.JsonValidationIssues.STRING_LENGTH_MISMATCH(semanticPath, message);
                    context.addIssue(issue);
                    result = false;
                }
            }
        }
        if (result) {
            if (!ClassPropertyValidator.validateClassPropertyValues(schema, propertyPath, propertyName, property, context)) {
                result = false;
            }
        }
        return result;
    }
    /**
     * Validate the values that are given for certain properties of
     * the `ClassProperty`.
     *
     * This validates the `offset/scale/max/min/default/noData` values
     * of the given `ClassProperty`. This is supposed to be called
     * after (i.e. at the end of) `validateClassProperty`, when the
     * basic structure of the class property has already been
     * determined to be valid.
     *
     * @param schema - The `Schema`
     * @param propertyPath - The path for the `ValidationIssue` instances
     * @param propertyName - The name of the property
     * @param property - The property
     * @param context - The `ValidationContext`
     * @returns Whether the object was valid
     */
    static validateClassPropertyValues(schema, propertyPath, propertyName, property, context) {
        let result = true;
        // Validate the offset
        const offset = property.offset;
        if ((0, _3d_tiles_tools_1.defined)(offset)) {
            if (!ClassPropertyValueValidator_1.ClassPropertyValueValidator.validateOffsetScale(propertyPath, propertyName, property, "offset", offset, context)) {
                result = false;
            }
        }
        // Validate the scale
        const scale = property.scale;
        if ((0, _3d_tiles_tools_1.defined)(scale)) {
            if (!ClassPropertyValueValidator_1.ClassPropertyValueValidator.validateOffsetScale(propertyPath, propertyName, property, "scale", scale, context)) {
                result = false;
            }
        }
        // Validate the max
        const max = property.max;
        if ((0, _3d_tiles_tools_1.defined)(max)) {
            if (!ClassPropertyValueValidator_1.ClassPropertyValueValidator.validateMaxMin(propertyPath, propertyName, property, "max", max, context)) {
                result = false;
            }
        }
        // Validate the min
        const min = property.min;
        if ((0, _3d_tiles_tools_1.defined)(min)) {
            if (!ClassPropertyValueValidator_1.ClassPropertyValueValidator.validateMaxMin(propertyPath, propertyName, property, "min", min, context)) {
                result = false;
            }
        }
        const theDefault = property.default;
        if ((0, _3d_tiles_tools_1.defined)(theDefault)) {
            // Validate the structure of the default value
            if (!MetadataValueValidator_1.MetadataValueValidator.validateValueStructure(propertyPath, propertyName, property, "default", theDefault, schema, context)) {
                result = false;
            }
        }
        const noData = property.noData;
        if ((0, _3d_tiles_tools_1.defined)(noData)) {
            // Validate the structure of the noData value
            if (!MetadataValueValidator_1.MetadataValueValidator.validateValueStructure(propertyPath, propertyName, property, "noData", noData, schema, context)) {
                result = false;
            }
        }
        return result;
    }
}
exports.ClassPropertyValidator = ClassPropertyValidator;
