"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoundingVolumeChecks = void 0;
// Mostly taken from https://github.com/CesiumGS/3d-tiles-validator/tree/e84202480eb6572383008076150c8e52c99af3c3
const cesium_1 = require("cesium");
const _3d_tiles_tools_1 = require("3d-tiles-tools");
/**
 * The checks for bounding volumes from the the original 3d-tiles-validator.
 */
class BoundingVolumeChecks {
    /**
     * The only public method:
     *
     * Checks if the given inner bounding volume is contained in
     * the given outer bounding volume, taking the given transforms
     * into account.
     *
     * If the inner bounding volume is contained in the outer one,
     * then `undefined` is returned.
     * Otherwise, an error message is returned.
     *
     * @param innerBoundingVolume - The inner `BoundingVolume`
     * @param outerBoundingVolume - The outer `BoundingVolume`
     * @param innerTransformArray - The inner transform as an array of 16 elements
     * @param outerTransformArray - The outer transform as an array of 16 elements
     * @returns An error message, or `undefined`
     */
    static checkBoundingVolume(innerBoundingVolume, outerBoundingVolume, innerTransformArray, outerTransformArray) {
        let innerTransform = cesium_1.Matrix4.IDENTITY;
        if ((0, _3d_tiles_tools_1.defined)(innerTransformArray)) {
            innerTransform = cesium_1.Matrix4.fromArray(innerTransformArray);
        }
        let outerTransform = cesium_1.Matrix4.IDENTITY;
        if ((0, _3d_tiles_tools_1.defined)(outerTransformArray)) {
            outerTransform = cesium_1.Matrix4.fromArray(outerTransformArray);
        }
        if ((0, _3d_tiles_tools_1.defined)(innerBoundingVolume.box) && (0, _3d_tiles_tools_1.defined)(outerBoundingVolume.box)) {
            // Box in Box check
            const transformedInnerTile = BoundingVolumeChecks.getTransformedBox(innerBoundingVolume.box, innerTransform);
            const transformedOuterTile = BoundingVolumeChecks.getTransformedBox(outerBoundingVolume.box, outerTransform);
            if (!BoundingVolumeChecks.boxInsideBox(transformedInnerTile, transformedOuterTile)) {
                return `box [${innerBoundingVolume.box}] is not within box [${outerBoundingVolume.box}]`;
            }
        }
        else if ((0, _3d_tiles_tools_1.defined)(innerBoundingVolume.sphere) &&
            (0, _3d_tiles_tools_1.defined)(outerBoundingVolume.sphere)) {
            // Sphere in Sphere
            const transformedInnerTile = BoundingVolumeChecks.getTransformedSphere(innerBoundingVolume.sphere, innerTransform);
            const transformedOuterTile = BoundingVolumeChecks.getTransformedSphere(outerBoundingVolume.sphere, outerTransform);
            if (!BoundingVolumeChecks.sphereInsideSphere(transformedInnerTile, transformedOuterTile)) {
                return `sphere [${innerBoundingVolume.sphere}] is not within sphere [${outerBoundingVolume.sphere}]`;
            }
        }
        else if ((0, _3d_tiles_tools_1.defined)(innerBoundingVolume.region) &&
            (0, _3d_tiles_tools_1.defined)(outerBoundingVolume.region)) {
            // Region in Region
            // Region does not update with transform
            const transformedInnerTile = innerBoundingVolume.region;
            const transformedOuterTile = outerBoundingVolume.region;
            if (!BoundingVolumeChecks.regionInsideRegion(transformedInnerTile, transformedOuterTile)) {
                return `region [${innerBoundingVolume.region}] is not within region [${outerBoundingVolume.region}]`;
            }
        }
        else if ((0, _3d_tiles_tools_1.defined)(innerBoundingVolume.box) &&
            (0, _3d_tiles_tools_1.defined)(outerBoundingVolume.sphere)) {
            // Box in Sphere
            const transformedInnerTile = BoundingVolumeChecks.getTransformedBox(innerBoundingVolume.box, innerTransform);
            const transformedOuterTile = BoundingVolumeChecks.getTransformedSphere(outerBoundingVolume.sphere, outerTransform);
            if (!BoundingVolumeChecks.boxInsideSphere(transformedInnerTile, transformedOuterTile)) {
                return `box [${innerBoundingVolume.box}] is not within sphere [${outerBoundingVolume.sphere}]`;
            }
        }
        else if ((0, _3d_tiles_tools_1.defined)(innerBoundingVolume.sphere) &&
            (0, _3d_tiles_tools_1.defined)(outerBoundingVolume.box)) {
            // Sphere in Box
            const transformedInnerTile = BoundingVolumeChecks.getTransformedSphere(innerBoundingVolume.sphere, innerTransform);
            const transformedOuterTile = BoundingVolumeChecks.getTransformedBox(outerBoundingVolume.box, outerTransform);
            if (!BoundingVolumeChecks.sphereInsideBox(transformedInnerTile, transformedOuterTile)) {
                return `sphere [${innerBoundingVolume.sphere}] is not within box [${outerBoundingVolume.box}]`;
            }
        }
    }
    static getTransformedBox(box, transform) {
        let center = cesium_1.Cartesian3.fromElements(box[0], box[1], box[2], BoundingVolumeChecks.scratchCenter);
        let halfAxes = cesium_1.Matrix3.fromArray(box, 3, BoundingVolumeChecks.scratchHalfAxes);
        // Find the transformed center and halfAxes
        center = cesium_1.Matrix4.multiplyByPoint(transform, center, center);
        const rotationScale = cesium_1.Matrix4.getMatrix3(transform, BoundingVolumeChecks.scratchMatrix);
        halfAxes = cesium_1.Matrix3.multiply(rotationScale, halfAxes, halfAxes);
        // Return a Box array
        const returnBox = [
            center.x,
            center.y,
            center.z,
            halfAxes[0],
            halfAxes[3],
            halfAxes[6],
            halfAxes[1],
            halfAxes[4],
            halfAxes[7],
            halfAxes[2],
            halfAxes[5],
            halfAxes[8],
        ];
        return returnBox;
    }
    static getTransformedSphere(sphere, transform) {
        let center = cesium_1.Cartesian3.fromElements(sphere[0], sphere[1], sphere[2], BoundingVolumeChecks.scratchCenter);
        let radius = sphere[3];
        // Find the transformed center and radius
        center = cesium_1.Matrix4.multiplyByPoint(transform, center, center);
        const scale = cesium_1.Matrix4.getScale(transform, BoundingVolumeChecks.scratchScale);
        const uniformScale = cesium_1.Cartesian3.maximumComponent(scale);
        radius *= uniformScale;
        // Return a Sphere array
        const returnSphere = [center.x, center.y, center.z, radius];
        return returnSphere;
    }
    static regionInsideRegion(regionInner, regionOuter) {
        return (regionInner[0] >= regionOuter[0] &&
            regionInner[1] >= regionOuter[1] &&
            regionInner[2] <= regionOuter[2] &&
            regionInner[3] <= regionOuter[3] &&
            regionInner[4] >= regionOuter[4] &&
            regionInner[5] <= regionOuter[5]);
    }
    static sphereInsideSphere(sphereInner, sphereOuter) {
        const radiusInner = sphereInner[3];
        const radiusOuter = sphereOuter[3];
        const centerInner = cesium_1.Cartesian3.unpack(sphereInner, 0, BoundingVolumeChecks.scratchInnerCenter);
        const centerOuter = cesium_1.Cartesian3.unpack(sphereOuter, 0, BoundingVolumeChecks.scratchOuterCenter);
        const distance = cesium_1.Cartesian3.distance(centerInner, centerOuter);
        return distance <= radiusOuter - radiusInner;
    }
    static boxInsideBox(boxInner, boxOuter) {
        const centerInner = cesium_1.Cartesian3.fromElements(boxInner[0], boxInner[1], boxInner[2], BoundingVolumeChecks.scratchInnerCenter);
        const halfAxesInner = cesium_1.Matrix3.fromArray(boxInner, 3, BoundingVolumeChecks.scratchInnerHalfAxes);
        const transformInner = cesium_1.Matrix4.fromRotationTranslation(halfAxesInner, centerInner);
        const centerOuter = cesium_1.Cartesian3.fromElements(boxOuter[0], boxOuter[1], boxOuter[2], BoundingVolumeChecks.scratchOuterCenter);
        const halfAxesOuter = cesium_1.Matrix3.fromArray(boxOuter, 3, BoundingVolumeChecks.scratchOuterHalfAxes);
        const transformOuter = cesium_1.Matrix4.fromRotationTranslation(halfAxesOuter, centerOuter);
        const cube = BoundingVolumeChecks.createUnitCube();
        const transformInnerInverse = cesium_1.Matrix4.inverse(transformOuter, transformOuter);
        for (let i = 0; i < 8; i++) {
            cube[i] = cesium_1.Matrix4.multiplyByPoint(transformInner, cube[i], cube[i]);
            cube[i] = cesium_1.Matrix4.multiplyByPoint(transformInnerInverse, cube[i], cube[i]);
            const min = cesium_1.Cartesian3.minimumComponent(cube[i]);
            const max = cesium_1.Cartesian3.maximumComponent(cube[i]);
            if (min < -1.0 - cesium_1.Math.EPSILON8 || max > 1.0 + cesium_1.Math.EPSILON8) {
                return false;
            }
        }
        return true;
    }
    static boxInsideSphere(box, sphere) {
        const centerBox = cesium_1.Cartesian3.fromElements(box[0], box[1], box[2], BoundingVolumeChecks.scratchBoxCenter);
        const halfAxesBox = cesium_1.Matrix3.fromArray(box, 3, BoundingVolumeChecks.scratchBoxHalfAxes);
        const transformBox = cesium_1.Matrix4.fromRotationTranslation(halfAxesBox, centerBox);
        const radiusSphere = sphere[3];
        const centerSphere = cesium_1.Cartesian3.unpack(sphere, 0, BoundingVolumeChecks.scratchSphereCenter);
        const cube = BoundingVolumeChecks.createUnitCube();
        for (let i = 0; i < 8; i++) {
            cube[i] = cesium_1.Matrix4.multiplyByPoint(transformBox, cube[i], cube[i]);
            const distance = cesium_1.Cartesian3.distance(cube[i], centerSphere);
            if (distance > radiusSphere) {
                return false;
            }
        }
        return true;
    }
    static sphereInsideBox(sphere, box) {
        const centerBox = cesium_1.Cartesian3.fromElements(box[0], box[1], box[2], BoundingVolumeChecks.scratchBoxCenter);
        const halfAxesBox = cesium_1.Matrix3.fromArray(box, 3, BoundingVolumeChecks.scratchBoxHalfAxes);
        const transformBox = cesium_1.Matrix4.fromRotationTranslation(halfAxesBox, centerBox);
        const radiusSphere = sphere[3];
        const centerSphere = cesium_1.Cartesian3.unpack(sphere, 0, BoundingVolumeChecks.scratchSphereCenter);
        const cube = BoundingVolumeChecks.createUnitCube();
        for (let i = 0; i < 8; i++) {
            cube[i] = cesium_1.Matrix4.multiplyByPoint(transformBox, cube[i], cube[i]);
        }
        const face = new Array(6);
        face[0] = BoundingVolumeChecks.planeFromPoints(cube[0], cube[1], cube[2]);
        face[1] = BoundingVolumeChecks.planeFromPoints(cube[2], cube[6], cube[7]);
        face[2] = BoundingVolumeChecks.planeFromPoints(cube[6], cube[5], cube[4]);
        face[3] = BoundingVolumeChecks.planeFromPoints(cube[5], cube[1], cube[0]);
        face[4] = BoundingVolumeChecks.planeFromPoints(cube[6], cube[2], cube[1]);
        face[5] = BoundingVolumeChecks.planeFromPoints(cube[0], cube[3], cube[7]);
        const boundingSphere = new cesium_1.BoundingSphere(centerSphere, radiusSphere);
        for (let i = 0; i < 6; i++) {
            const intersection = cesium_1.BoundingSphere.intersectPlane(boundingSphere, face[i]);
            if (intersection !== cesium_1.Intersect.INSIDE) {
                return false;
            }
        }
        return true;
    }
    static planeFromPoints(point1, point2, point3) {
        const a = new cesium_1.Cartesian3();
        const b = new cesium_1.Cartesian3();
        const c = new cesium_1.Cartesian3();
        const normal = new cesium_1.Cartesian3();
        cesium_1.Cartesian3.subtract(point2, point1, a);
        cesium_1.Cartesian3.subtract(point3, point2, b);
        cesium_1.Cartesian3.cross(a, b, c);
        cesium_1.Cartesian3.normalize(c, normal);
        return cesium_1.Plane.fromPointNormal(point1, normal);
    }
    static createUnitCube() {
        const cube = new Array(8);
        cube[0] = new cesium_1.Cartesian3(-1, -1, -1);
        cube[1] = new cesium_1.Cartesian3(-1, -1, 1);
        cube[2] = new cesium_1.Cartesian3(1, -1, 1);
        cube[3] = new cesium_1.Cartesian3(1, -1, -1);
        cube[4] = new cesium_1.Cartesian3(-1, 1, -1);
        cube[5] = new cesium_1.Cartesian3(-1, 1, 1);
        cube[6] = new cesium_1.Cartesian3(1, 1, 1);
        cube[7] = new cesium_1.Cartesian3(1, 1, -1);
        return cube;
    }
}
exports.BoundingVolumeChecks = BoundingVolumeChecks;
BoundingVolumeChecks.scratchMatrix = new cesium_1.Matrix3();
BoundingVolumeChecks.scratchHalfAxes = new cesium_1.Matrix3();
BoundingVolumeChecks.scratchCenter = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchScale = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchInnerCenter = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchOuterCenter = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchInnerHalfAxes = new cesium_1.Matrix3();
BoundingVolumeChecks.scratchOuterHalfAxes = new cesium_1.Matrix3();
BoundingVolumeChecks.scratchBoxCenter = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchSphereCenter = new cesium_1.Cartesian3();
BoundingVolumeChecks.scratchBoxHalfAxes = new cesium_1.Matrix3();
