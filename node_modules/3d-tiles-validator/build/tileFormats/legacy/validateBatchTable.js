"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBatchTable = void 0;
// Mostly ported from https://github.com/CesiumGS/3d-tiles-validator/tree/e84202480eb6572383008076150c8e52c99af3c3
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const utility_1 = require("./utility");
const utility_2 = require("./utility");
/**
 * Checks if the batch table JSON and batch table binary are valid
 *
 * @param batchTableJson - Batch table JSON.
 * @param batchTableBinary - Batch table binary.
 * @param featuresLength - The number of features.
 * @returns An error message if validation fails, otherwise undefined.
 *
 * @internal
 */
function validateBatchTable(batchTableJson, batchTableBinary, featuresLength) {
    for (const name in batchTableJson) {
        if (Object.prototype.hasOwnProperty.call(batchTableJson, name)) {
            if (name === "extensions" || name === "extras") {
                continue;
            }
            if (hasDracoProperty(batchTableJson, name)) {
                continue;
            }
            const property = batchTableJson[name];
            const byteOffset = property.byteOffset;
            if ((0, _3d_tiles_tools_1.defined)(byteOffset)) {
                if (typeof byteOffset !== "number") {
                    return `Batch table binary property "${name}" byteOffset must be a number.`;
                }
                const componentType = property.componentType;
                const type = property.type;
                if (!(0, _3d_tiles_tools_1.defined)(type)) {
                    return `Batch table binary property "${name}" must have a type.`;
                }
                if (!(0, _3d_tiles_tools_1.defined)(componentType)) {
                    return `Batch table binary property "${name}" must have a componentType.`;
                }
                const componentsLength = (0, utility_1.typeToComponentsLength)(type);
                const componentByteLength = (0, utility_2.componentTypeToByteLength)(componentType);
                if (!(0, _3d_tiles_tools_1.defined)(componentsLength)) {
                    return `Batch table binary property "${name}" has invalid type "${type}".`;
                }
                if (!(0, _3d_tiles_tools_1.defined)(componentByteLength)) {
                    return `Batch table binary property "${name}" has invalid componentType "${componentType}".`;
                }
                if (byteOffset % componentByteLength > 0) {
                    return `Batch table binary property "${name}" must be aligned to a ${componentByteLength}-byte boundary.`;
                }
                const propertyByteLength = componentsLength * componentByteLength * featuresLength;
                if (byteOffset + propertyByteLength > batchTableBinary.length) {
                    return `Batch table binary property "${name}" exceeds batch table binary byte length.`;
                }
            }
            else {
                if (!Array.isArray(property)) {
                    return `Batch table property "${name}" must be an array.`;
                }
                if (property.length !== featuresLength) {
                    return `Batch table property "${name}" array length must equal features length ${featuresLength}.`;
                }
            }
        }
    }
}
exports.validateBatchTable = validateBatchTable;
function hasDracoProperty(batchTableJson, propertyName) {
    const extensions = batchTableJson.extensions;
    if ((0, _3d_tiles_tools_1.defined)(extensions)) {
        const dracoExtension = extensions["3DTILES_draco_point_compression"];
        if ((0, _3d_tiles_tools_1.defined)(dracoExtension)) {
            return (0, _3d_tiles_tools_1.defined)(dracoExtension.properties[propertyName]);
        }
    }
    return false;
}
