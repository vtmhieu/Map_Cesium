"use strict";
// Mostly ported from https://github.com/CesiumGS/3d-tiles-validator/tree/e84202480eb6572383008076150c8e52c99af3c3
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFeatureTable = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const utility_1 = require("./utility");
const utility_2 = require("./utility");
/**
 * Checks if the feature table JSON and feature table binary are valid
 *
 * @param featureTableJson - Feature table JSON.
 * @param featureTableBinary - Feature table binary.
 * @param featuresLength - The number of features.
 * @param featureTableSemantics - An object containing semantic information for each feature table property, specific to the tile format.
 * @returns An error message if validation fails, otherwise undefined.
 *
 * @internal
 */
function validateFeatureTable(featureTableJson, featureTableBinary, featuresLength, featureTableSemantics) {
    for (const name in featureTableJson) {
        if (Object.prototype.hasOwnProperty.call(featureTableJson, name)) {
            if (name === "extensions" || name === "extras") {
                continue;
            }
            const property = featureTableJson[name];
            const definition = featureTableSemantics[name];
            if (!(0, _3d_tiles_tools_2.defined)(definition)) {
                return `Invalid feature table property "${name}".`;
            }
            if (hasDracoProperty(featureTableJson, name)) {
                continue;
            }
            const byteOffset = property.byteOffset;
            const componentType = (0, _3d_tiles_tools_1.defaultValue)(property.componentType, definition.componentType);
            const componentTypeOptions = definition.componentTypeOptions;
            const type = definition.type;
            const componentsLength = (0, utility_1.typeToComponentsLength)(type);
            const componentByteLength = (0, utility_2.componentTypeToByteLength)(componentType);
            const itemsLength = definition.global ? 1 : featuresLength;
            if ((0, _3d_tiles_tools_2.defined)(byteOffset)) {
                if (!(0, _3d_tiles_tools_2.defined)(componentsLength)) {
                    return `Feature table binary property "${name}" has invalid type "${type}".`;
                }
                if (!(0, _3d_tiles_tools_2.defined)(componentByteLength)) {
                    return `Feate table binary property "${name}" has invalid componentType "${componentType}".`;
                }
                if (typeof byteOffset !== "number") {
                    return `Feature table binary property "${name}" byteOffset must be a number.`;
                }
                if ((0, _3d_tiles_tools_2.defined)(componentTypeOptions) &&
                    (0, _3d_tiles_tools_2.defined)(componentTypeOptions) &&
                    componentTypeOptions.indexOf(componentType) === -1) {
                    return `Feature table binary property "${name}" has invalid componentType "${componentType}".`;
                }
                if (byteOffset % componentByteLength > 0) {
                    return `Feature table binary property "${name}" must be aligned to a ${componentByteLength}-byte boundary.`;
                }
                const propertyByteLength = componentsLength * componentByteLength * itemsLength;
                if (byteOffset + propertyByteLength > featureTableBinary.length) {
                    return `Feature table binary property "${name}" exceeds feature table binary byte length.`;
                }
            }
            else if (type === "boolean") {
                if (typeof property !== "boolean") {
                    return `Feature table property "${name}" must be a boolean.`;
                }
            }
            else {
                if (!(0, _3d_tiles_tools_2.defined)(componentsLength)) {
                    return `Feature table binary property "${name}" has invalid type "${type}".`;
                }
                const arrayLength = componentsLength * itemsLength;
                if (definition.global && arrayLength === 1) {
                    if (typeof property !== "number") {
                        return `Feature table property "${name}" must be a number.`;
                    }
                }
                else {
                    if (!Array.isArray(property)) {
                        return `Feature table property "${name}" must be an array.`;
                    }
                    if (property.length !== arrayLength) {
                        return `Feature table property "${name}" must be an array of length ${arrayLength}.`;
                    }
                    for (let i = 0; i < arrayLength; i++) {
                        if (typeof property[i] !== "number") {
                            return `Feature table property "${name}" array must contain numbers only.`;
                        }
                    }
                }
            }
        }
    }
}
exports.validateFeatureTable = validateFeatureTable;
function hasDracoProperty(featureTableJson, propertyName) {
    const extensions = featureTableJson.extensions;
    if ((0, _3d_tiles_tools_2.defined)(extensions)) {
        const dracoExtension = extensions["3DTILES_draco_point_compression"];
        if ((0, _3d_tiles_tools_2.defined)(dracoExtension)) {
            return (0, _3d_tiles_tools_2.defined)(dracoExtension.properties[propertyName]);
        }
    }
    return false;
}
