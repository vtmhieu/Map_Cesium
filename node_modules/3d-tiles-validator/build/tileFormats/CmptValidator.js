"use strict";
// This was, to some extent, "ported" (or at least "inspired") from
// https://github.com/CesiumGS/3d-tiles-validator/blob/e84202480eb6572383008076150c8e52c99af3c3/validator/lib/validateCmpt.js
// It still contains legacy elements that may be cleaned up at some point.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CmptValidator = void 0;
const I3dmValidator_1 = require("./I3dmValidator");
const PntsValidator_1 = require("./PntsValidator");
const B3dmValidator_1 = require("./B3dmValidator");
const TileFormatValidator_1 = require("./TileFormatValidator");
const BinaryValidationIssues_1 = require("../issues/BinaryValidationIssues");
/**
 * A class that can perform validation of CMPT data that is
 * given as a Buffer.
 *
 * @internal
 */
class CmptValidator {
    async validateObject(uri, input, context) {
        const headerByteLength = 16;
        if (!TileFormatValidator_1.TileFormatValidator.validateHeader(uri, input, headerByteLength, "cmpt", context)) {
            return false;
        }
        const byteLength = input.readUInt32LE(8);
        const tilesLength = input.readUInt32LE(12);
        let result = true;
        let byteOffset = headerByteLength;
        for (let i = 0; i < tilesLength; i++) {
            if (byteOffset + 12 > byteLength) {
                const message = "Cannot read byte length from inner tile, exceeds cmpt tile's byte length.";
                const issue = BinaryValidationIssues_1.BinaryValidationIssues.BINARY_INVALID(uri, message);
                context.addIssue(issue);
                return false;
            }
            if (byteOffset % 8 > 0) {
                const message = "Inner tile must be aligned to an 8-byte boundary";
                const issue = BinaryValidationIssues_1.BinaryValidationIssues.BINARY_INVALID(uri, message);
                context.addIssue(issue);
                return false;
            }
            const innerTileMagic = input.toString("utf8", byteOffset, byteOffset + 4);
            const innerTileByteLength = input.readUInt32LE(byteOffset + 8);
            const innerTile = input.slice(byteOffset, byteOffset + innerTileByteLength);
            if (innerTileMagic === "b3dm") {
                const innerValidator = new B3dmValidator_1.B3dmValidator();
                const innerResult = await innerValidator.validateObject(uri, innerTile, context);
                if (!innerResult) {
                    result = false;
                }
            }
            else if (innerTileMagic === "i3dm") {
                const innerValidator = new I3dmValidator_1.I3dmValidator();
                const innerResult = await innerValidator.validateObject(uri, innerTile, context);
                if (!innerResult) {
                    result = false;
                }
            }
            else if (innerTileMagic === "pnts") {
                const innerValidator = new PntsValidator_1.PntsValidator();
                const innerResult = await innerValidator.validateObject(uri, innerTile, context);
                if (!innerResult) {
                    result = false;
                }
            }
            else if (innerTileMagic === "cmpt") {
                const innerValidator = new CmptValidator();
                const innerResult = await innerValidator.validateObject(uri, innerTile, context);
                if (!innerResult) {
                    result = false;
                }
            }
            else {
                const message = `Invalid inner tile magic: ${innerTileMagic}`;
                const issue = BinaryValidationIssues_1.BinaryValidationIssues.BINARY_INVALID(uri, message);
                context.addIssue(issue);
                result = false;
            }
            byteOffset += innerTileByteLength;
        }
        return result;
    }
}
exports.CmptValidator = CmptValidator;
