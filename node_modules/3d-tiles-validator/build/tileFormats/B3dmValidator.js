"use strict";
// This was, to some extent, "ported" (or at least "inspired") from
// https://github.com/CesiumGS/3d-tiles-validator/blob/e84202480eb6572383008076150c8e52c99af3c3/validator/lib/validateB3dm.js
// It still contains legacy elements that may be cleaned up at some point.
Object.defineProperty(exports, "__esModule", { value: true });
exports.B3dmValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const GltfValidator_1 = require("./GltfValidator");
const TileFormatValidator_1 = require("./TileFormatValidator");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const BinaryValidationIssues_1 = require("../issues/BinaryValidationIssues");
const ContentValidationIssues_1 = require("../issues/ContentValidationIssues");
const validateBatchTable_1 = require("./legacy/validateBatchTable");
const validateFeatureTable_1 = require("./legacy/validateFeatureTable");
const featureTableSemantics = {
    BATCH_LENGTH: {
        global: true,
        type: "SCALAR",
        componentType: "UNSIGNED_INT",
    },
    RTC_CENTER: {
        global: true,
        type: "VEC3",
        componentType: "FLOAT",
    },
};
/**
 * A class that can perform validation of B3DM data that is
 * given as a Buffer.
 *
 * @internal
 */
class B3dmValidator {
    async validateObject(uri, input, context) {
        const headerByteLength = 28;
        if (!TileFormatValidator_1.TileFormatValidator.validateHeader(uri, input, headerByteLength, "b3dm", context)) {
            return false;
        }
        // Legacy header #1: [batchLength] [batchTableByteLength]
        // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
        // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
        // If the header is in the first legacy format 'batchTableJsonByteLength' will
        // be the start of the JSON string (a quotation mark) or the glTF magic.
        // Accordingly its first byte will be either 0x22 or 0x67, and so the
        // minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is
        // unlikely that the batch table JSON will exceed this length.
        // The check for the second legacy format is similar, except it checks
        // 'batchTableBinaryByteLength' instead
        const batchTableJsonByteLength = input.readUInt32LE(20);
        const batchTableBinaryByteLength = input.readUInt32LE(24);
        if (batchTableJsonByteLength >= 570425344) {
            const message = `Header is using the legacy format [batchLength] ` +
                `[batchTableByteLength]. The new format is ` +
                `[featureTableJsonByteLength] [featureTableBinaryByteLength] ` +
                `[batchTableJsonByteLength] [batchTableBinaryByteLength].`;
            const issue = BinaryValidationIssues_1.BinaryValidationIssues.BINARY_INVALID(uri, message);
            context.addIssue(issue);
            return false;
        }
        if (batchTableBinaryByteLength >= 570425344) {
            const message = `Header is using the legacy format [batchTableJsonByteLength] ` +
                `[batchTableBinaryByteLength] [batchLength]. The new format is ` +
                `[featureTableJsonByteLength] [featureTableBinaryByteLength] ` +
                `[batchTableJsonByteLength] [batchTableBinaryByteLength].`;
            const issue = BinaryValidationIssues_1.BinaryValidationIssues.BINARY_INVALID(uri, message);
            context.addIssue(issue);
            return false;
        }
        const binaryTableData = TileFormatValidator_1.TileFormatValidator.extractBinaryTableData(uri, input, headerByteLength, true, context);
        if (!(0, _3d_tiles_tools_1.defined)(binaryTableData)) {
            return false;
        }
        const featureTableJson = binaryTableData.featureTableJson;
        const featureTableBinary = binaryTableData.featureTableBinary;
        const batchTableJson = binaryTableData.batchTableJson;
        const batchTableBinary = binaryTableData.batchTableBinary;
        const glbData = binaryTableData.glbData;
        const featuresLength = featureTableJson.BATCH_LENGTH;
        if (!(0, _3d_tiles_tools_1.defined)(featuresLength)) {
            const message = `Feature table must contain a BATCH_LENGTH property.`;
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            return false;
        }
        const featureTableMessage = (0, validateFeatureTable_1.validateFeatureTable)(featureTableJson, featureTableBinary, featuresLength, featureTableSemantics);
        if ((0, _3d_tiles_tools_1.defined)(featureTableMessage)) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_JSON_INVALID(uri, featureTableMessage);
            context.addIssue(issue);
            return false;
        }
        const batchTableMessage = (0, validateBatchTable_1.validateBatchTable)(batchTableJson, batchTableBinary, featuresLength);
        if ((0, _3d_tiles_tools_1.defined)(batchTableMessage)) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_JSON_INVALID(uri, batchTableMessage);
            context.addIssue(issue);
            return false;
        }
        if ((0, _3d_tiles_tools_1.defined)(batchTableJson.extensions)) {
            const extensionNames = Object.keys(batchTableJson.extensions);
            for (const extensionFound of extensionNames) {
                context.addExtensionFound(extensionFound);
            }
        }
        const gltfValidator = new GltfValidator_1.GltfValidator();
        const result = await gltfValidator.validateObject(uri, glbData, context);
        return result;
    }
}
exports.B3dmValidator = B3dmValidator;
