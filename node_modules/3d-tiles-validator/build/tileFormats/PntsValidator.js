"use strict";
// This was, to some extent, "ported" (or at least "inspired") from
// https://github.com/CesiumGS/3d-tiles-validator/blob/e84202480eb6572383008076150c8e52c99af3c3/validator/lib/validatePnts.js
// It still contains legacy elements that may be cleaned up at some point.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PntsValidator = void 0;
const _3d_tiles_tools_1 = require("3d-tiles-tools");
const _3d_tiles_tools_2 = require("3d-tiles-tools");
const TileFormatValidator_1 = require("./TileFormatValidator");
const IoValidationIssue_1 = require("../issues/IoValidationIssue");
const ContentValidationIssues_1 = require("../issues/ContentValidationIssues");
const validateBatchTable_1 = require("./legacy/validateBatchTable");
const validateFeatureTable_1 = require("./legacy/validateFeatureTable");
const featureTableSemantics = {
    POSITION: {
        global: false,
        type: "VEC3",
        componentType: "FLOAT",
    },
    POSITION_QUANTIZED: {
        global: false,
        type: "VEC3",
        componentType: "UNSIGNED_SHORT",
    },
    RGBA: {
        global: false,
        type: "VEC4",
        componentType: "UNSIGNED_BYTE",
    },
    RGB: {
        global: false,
        type: "VEC3",
        componentType: "UNSIGNED_BYTE",
    },
    RGB565: {
        global: false,
        type: "SCALAR",
        componentType: "UNSIGNED_SHORT",
    },
    NORMAL: {
        global: false,
        type: "VEC3",
        componentType: "FLOAT",
    },
    NORMAL_OCT16P: {
        global: false,
        type: "VEC2",
        componentType: "UNSIGNED_BYTE",
    },
    BATCH_ID: {
        global: false,
        type: "SCALAR",
        componentType: "UNSIGNED_SHORT",
        componentTypeOptions: ["UNSIGNED_BYTE", "UNSIGNED_SHORT", "UNSIGNED_INT"],
    },
    POINTS_LENGTH: {
        global: true,
        type: "SCALAR",
        componentType: "UNSIGNED_INT",
    },
    RTC_CENTER: {
        global: true,
        type: "VEC3",
        componentType: "FLOAT",
    },
    QUANTIZED_VOLUME_OFFSET: {
        global: true,
        type: "VEC3",
        componentType: "FLOAT",
    },
    QUANTIZED_VOLUME_SCALE: {
        global: true,
        type: "VEC3",
        componentType: "FLOAT",
    },
    CONSTANT_RGBA: {
        global: true,
        type: "VEC4",
        componentType: "UNSIGNED_BYTE",
    },
    BATCH_LENGTH: {
        global: true,
        type: "SCALAR",
        componentType: "UNSIGNED_INT",
    },
};
/**
 * A class that can perform validation of PNTS data that is
 * given as a Buffer.
 *
 * @internal
 */
class PntsValidator {
    async validateObject(uri, input, context) {
        const headerByteLength = 28;
        if (!TileFormatValidator_1.TileFormatValidator.validateHeader(uri, input, headerByteLength, "pnts", context)) {
            return false;
        }
        const binaryTableData = TileFormatValidator_1.TileFormatValidator.extractBinaryTableData(uri, input, headerByteLength, false, context);
        if (!(0, _3d_tiles_tools_1.defined)(binaryTableData)) {
            return false;
        }
        const featureTableJson = binaryTableData.featureTableJson;
        const featureTableBinary = binaryTableData.featureTableBinary;
        const batchTableJson = binaryTableData.batchTableJson;
        const batchTableBinary = binaryTableData.batchTableBinary;
        let result = true;
        const batchLength = (0, _3d_tiles_tools_2.defaultValue)(featureTableJson.BATCH_LENGTH, 0);
        const pointsLength = featureTableJson.POINTS_LENGTH;
        if (!(0, _3d_tiles_tools_1.defined)(pointsLength)) {
            const message = "Feature table must contain a POINTS_LENGTH property.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if (!(0, _3d_tiles_tools_1.defined)(featureTableJson.POSITION) &&
            !(0, _3d_tiles_tools_1.defined)(featureTableJson.POSITION_QUANTIZED)) {
            const message = "Feature table must contain either the POSITION or POSITION_QUANTIZED property.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if ((0, _3d_tiles_tools_1.defined)(featureTableJson.POSITION_QUANTIZED) &&
            (!(0, _3d_tiles_tools_1.defined)(featureTableJson.QUANTIZED_VOLUME_OFFSET) ||
                !(0, _3d_tiles_tools_1.defined)(featureTableJson.QUANTIZED_VOLUME_SCALE))) {
            const message = "Feature table properties QUANTIZED_VOLUME_OFFSET and QUANTIZED_VOLUME_SCALE are required when POSITION_QUANTIZED is present.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if ((0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_ID) &&
            !(0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_LENGTH)) {
            const message = "Feature table property BATCH_LENGTH is required when BATCH_ID is present.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if (!(0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_ID) &&
            (0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_LENGTH)) {
            const message = "Feature table property BATCH_ID is required when BATCH_LENGTH is present.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if (batchLength > pointsLength) {
            const message = "Feature table property BATCH_LENGTH must be less than or equal to POINTS_LENGTH.";
            const issue = IoValidationIssue_1.IoValidationIssues.JSON_PARSE_ERROR(uri, message);
            context.addIssue(issue);
            result = false;
        }
        if ((0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_ID) &&
            !hasDracoBatchIds(featureTableJson)) {
            /* TODO Revive this part of the validation
              const featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);
              featureTable.featuresLength = pointsLength;
              const componentDatatype = ComponentDatatype.fromName(defaultValue(featureTableJson.BATCH_ID.componentType, 'UNSIGNED_SHORT'));
              const batchIds = featureTable.getPropertyArray('BATCH_ID', componentDatatype, 1);
              const length = batchIds.length;
              for (let i = 0; i < length; i++) {
                  if (batchIds[i] >= featureTableJson.BATCH_LENGTH) {
                    const message = 'All the BATCH_IDs must have values less than feature table property BATCH_LENGTH.';
                    const issue = IoValidationIssues.JSON_PARSE_ERROR(uri, message);
                    context.addIssue(issue);
                          }
              }
              */
        }
        const featureTableMessage = (0, validateFeatureTable_1.validateFeatureTable)(featureTableJson, featureTableBinary, pointsLength, featureTableSemantics);
        if ((0, _3d_tiles_tools_1.defined)(featureTableMessage)) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_JSON_INVALID(uri, featureTableMessage);
            context.addIssue(issue);
            result = false;
        }
        // If the BATCH_ID semantic is defined, the Batch Table stores metadata
        // for each batchId, and the length of the Batch Table arrays will
        // equal BATCH_LENGTH. Otherwise, it will store per-point metadata,
        // and the length will be POINTS_LENGTH.
        let batchTableArraysLength = pointsLength;
        if ((0, _3d_tiles_tools_1.defined)(featureTableJson.BATCH_ID)) {
            batchTableArraysLength = batchLength;
        }
        const batchTableMessage = (0, validateBatchTable_1.validateBatchTable)(batchTableJson, batchTableBinary, batchTableArraysLength);
        if ((0, _3d_tiles_tools_1.defined)(batchTableMessage)) {
            const issue = ContentValidationIssues_1.ContentValidationIssues.CONTENT_JSON_INVALID(uri, batchTableMessage);
            context.addIssue(issue);
            result = false;
        }
        return result;
    }
}
exports.PntsValidator = PntsValidator;
function hasDracoBatchIds(featureTableJson) {
    const extensions = featureTableJson.extensions;
    if ((0, _3d_tiles_tools_1.defined)(extensions)) {
        const dracoExtension = extensions["3DTILES_draco_point_compression"];
        if ((0, _3d_tiles_tools_1.defined)(dracoExtension)) {
            return (0, _3d_tiles_tools_1.defined)(dracoExtension.properties.BATCH_ID);
        }
    }
    return false;
}
