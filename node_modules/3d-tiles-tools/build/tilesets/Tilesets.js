"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tilesets = void 0;
const path_1 = __importDefault(require("path"));
const ContentDataTypeChecks_1 = require("../contentTypes/ContentDataTypeChecks");
const ContentDataTypes_1 = require("../contentTypes/ContentDataTypes");
const TilesetCombiner_1 = require("../tilesetProcessing/TilesetCombiner");
const TilesetMerger_1 = require("../tilesetProcessing/TilesetMerger");
const TilesetUpgrader_1 = require("../tilesetProcessing/TilesetUpgrader");
/**
 * Methods related to tilesets.
 *
 * Most of the methods in this class are either utility methods, or
 * wrappers around the classes that implement parts of the command
 * line functionality (and that may become `TilesetStage`s in a
 * pipeline at some point).
 */
class Tilesets {
    /**
     * Performs the `combine` command line operation.
     *
     * @param tilesetSourceName - The tileset source name
     * @param tilesetTargetName - The tileset target name
     * @param overwrite Whether the target should be overwritten if
     * it already exists
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed,
     * or when the output already exists and `overwrite` was `false`.
     */
    static async combine(tilesetSourceName, tilesetTargetName, overwrite) {
        const externalTilesetDetector = ContentDataTypeChecks_1.ContentDataTypeChecks.createIncludedCheck(ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_TILESET);
        const tilesetCombiner = new TilesetCombiner_1.TilesetCombiner(externalTilesetDetector);
        await tilesetCombiner.combine(tilesetSourceName, tilesetTargetName, overwrite);
    }
    /**
     * Performs the `merge` command line operation.
     *
     * @param tilesetSourceName - The tileset source name
     * @param tilesetTargetName - The tileset target name
     * @param overwrite Whether the target should be overwritten if
     * it already exists
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed,
     * or when the output already exists and `overwrite` was `false`.
     */
    static async merge(tilesetSourceNames, tilesetTargetName, overwrite) {
        const tilesetMerger = new TilesetMerger_1.TilesetMerger();
        await tilesetMerger.merge(tilesetSourceNames, tilesetTargetName, overwrite);
    }
    /**
     * Performs the `upgrade` command line operation.
     *
     * @param tilesetSourceName - The tileset source name
     * @param tilesetTargetName - The tileset target name
     * @param overwrite Whether the target should be overwritten if
     * it already exists
     * @param gltfUpgradeOptions - Options that may be passed
     * to `gltf-pipeline` when GLB data in B3DM or I3DM is
     * supposed to be upgraded.
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed,
     * or when the output already exists and `overwrite` was `false`.
     */
    static async upgrade(tilesetSourceName, tilesetTargetName, overwrite, gltfUpgradeOptions) {
        const quiet = false;
        const tilesetUpgrader = new TilesetUpgrader_1.TilesetUpgrader(quiet, gltfUpgradeOptions);
        tilesetUpgrader.upgrade(tilesetSourceName, tilesetTargetName, overwrite);
    }
    /**
     * Performs the `upgrade` operation directly on a tileset
     *
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed
     */
    static async upgradeTileset(tileset) {
        const quiet = false;
        const gltfUpgradeOptions = undefined;
        const tilesetUpgrader = new TilesetUpgrader_1.TilesetUpgrader(quiet, gltfUpgradeOptions);
        await tilesetUpgrader.upgradeTileset(tileset);
    }
    /**
     * Determine the name of the file that contains the tileset JSON data.
     *
     * If the given name ends with '.json' (case insensitively), then the
     * name is the last path component of the given name.
     *
     * Otherwise (if the given name is a directory, or the name of a file
     * that does not end with '.json'), then the default name 'tileset.json'
     * is returned.
     *
     * @param tilesetSourceName - The tileset source name
     * @returns The tileset file name
     */
    static determineTilesetJsonFileName(tilesetSourceName) {
        if (tilesetSourceName.toLowerCase().endsWith(".json")) {
            return path_1.default.basename(tilesetSourceName);
        }
        return "tileset.json";
    }
    /**
     * Returns whether the given names likely refer to the same package.
     *
     * This will interpret the given strings as paths and normalize them.
     * When the names end with `.json` (case insensitively), then the
     * method returns whether the names refer to the same directory.
     * Otherwise, it returns whether the paths are equal.
     *
     * @param tilesetPackageName0 - The first package name
     * @param tilesetPackageName1 - The second package name
     * @returns Whether the names refer to the same package
     */
    static areEqualPackages(tilesetPackageName0, tilesetPackageName1) {
        let name0 = path_1.default.normalize(tilesetPackageName0);
        if (name0.toLowerCase().endsWith(".json")) {
            name0 = path_1.default.dirname(tilesetPackageName0);
        }
        let name1 = path_1.default.normalize(tilesetPackageName1);
        if (name1.toLowerCase().endsWith(".json")) {
            name1 = path_1.default.dirname(tilesetPackageName1);
        }
        return name0 === name1;
    }
}
exports.Tilesets = Tilesets;
