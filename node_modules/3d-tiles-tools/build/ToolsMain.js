"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolsMain = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const Paths_1 = require("./base/Paths");
const DeveloperError_1 = require("./base/DeveloperError");
const Buffers_1 = require("./base/Buffers");
const Tilesets_1 = require("./tilesets/Tilesets");
const TileFormats_1 = require("./tileFormats/TileFormats");
const TileDataLayouts_1 = require("./tileFormats/TileDataLayouts");
const ContentOps_1 = require("./contentProcessing/ContentOps");
const GtlfUtilities_1 = require("./contentProcessing/GtlfUtilities");
const ContentDataTypes_1 = require("./contentTypes/ContentDataTypes");
const PipelineExecutor_1 = require("./pipelines/PipelineExecutor");
const Pipelines_1 = require("./pipelines/Pipelines");
const ZipToPackage_1 = require("./packages/ZipToPackage");
const TilesetSources_1 = require("./tilesetData/TilesetSources");
const TilesetTargets_1 = require("./tilesetData/TilesetTargets");
/**
 * Functions that directly correspond to the command line functionality.
 *
 * The functions that directly operate on individual files (tile content),
 * like `cmptToGlb`, will just read the input data, perform the operation,
 * and write the output data.
 *
 * The "simple" tileset operations (like `combine` or `merge`) are
 * implemented based on the utility functions in the `Tilesets` class.
 *
 * Some operations (like `gzip`) are implemented by creating the
 * preliminary JSON representation of the processing pipeline, then
 * creating a `Pipeline` object from that, and executing that pipeline.
 */
class ToolsMain {
    static async b3dmToGlb(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        const inputBuffer = fs_1.default.readFileSync(input);
        const inputTileData = TileFormats_1.TileFormats.readTileData(inputBuffer);
        const outputBuffer = inputTileData.payload;
        const upgradedOutputBuffer = await GtlfUtilities_1.GltfUtilities.upgradeGlb(outputBuffer, undefined);
        fs_1.default.writeFileSync(output, upgradedOutputBuffer);
    }
    static async i3dmToGlb(input, output, force) {
        return ToolsMain.b3dmToGlb(input, output, force);
    }
    static async cmptToGlb(input, output, force) {
        const inputBuffer = fs_1.default.readFileSync(input);
        const glbBuffers = TileFormats_1.TileFormats.extractGlbBuffers(inputBuffer);
        const glbsLength = glbBuffers.length;
        const glbPaths = new Array(glbsLength);
        if (glbsLength === 0) {
            throw new DeveloperError_1.DeveloperError(`No glbs found in ${input}.`);
        }
        else if (glbsLength === 1) {
            glbPaths[0] = output;
        }
        else {
            const prefix = Paths_1.Paths.replaceExtension(output, "");
            for (let i = 0; i < glbsLength; ++i) {
                glbPaths[i] = `${prefix}_${i}.glb`;
            }
        }
        for (let i = 0; i < glbsLength; i++) {
            const glbPath = glbPaths[i];
            ToolsMain.ensureCanWrite(glbPath, force);
            const glbBuffer = glbBuffers[i];
            const upgradedOutputBuffer = await GtlfUtilities_1.GltfUtilities.upgradeGlb(glbBuffer, undefined);
            fs_1.default.writeFileSync(glbPath, upgradedOutputBuffer);
        }
    }
    static async glbToB3dm(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        const inputBuffer = fs_1.default.readFileSync(input);
        const outputTileData = TileFormats_1.TileFormats.createDefaultB3dmTileDataFromGlb(inputBuffer);
        const outputBuffer = TileFormats_1.TileFormats.createTileDataBuffer(outputTileData);
        fs_1.default.writeFileSync(output, outputBuffer);
    }
    static async glbToI3dm(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        const inputBuffer = fs_1.default.readFileSync(input);
        const outputTileData = TileFormats_1.TileFormats.createDefaultI3dmTileDataFromGlb(inputBuffer);
        const outputBuffer = TileFormats_1.TileFormats.createTileDataBuffer(outputTileData);
        fs_1.default.writeFileSync(output, outputBuffer);
    }
    static async optimizeB3dm(input, output, force, options) {
        ToolsMain.ensureCanWrite(output, force);
        const inputBuffer = fs_1.default.readFileSync(input);
        const outputBuffer = await ContentOps_1.ContentOps.optimizeB3dmBuffer(inputBuffer, options);
        fs_1.default.writeFileSync(output, outputBuffer);
    }
    static async optimizeI3dm(input, output, force, options) {
        ToolsMain.ensureCanWrite(output, force);
        const inputBuffer = fs_1.default.readFileSync(input);
        const outputBuffer = await ContentOps_1.ContentOps.optimizeI3dmBuffer(inputBuffer, options);
        fs_1.default.writeFileSync(output, outputBuffer);
    }
    static analyze(inputFileName, outputDirectoryName, force) {
        console.log(`Analyzing ${inputFileName}`);
        console.log(`writing results to ${outputDirectoryName}`);
        const inputBaseName = path_1.default.basename(inputFileName);
        const inputBuffer = fs_1.default.readFileSync(inputFileName);
        ToolsMain.analyzeInternal(inputBaseName, inputBuffer, outputDirectoryName, force);
    }
    static analyzeInternal(inputBaseName, inputBuffer, outputDirectoryName, force) {
        // A function to create a JSON string from an
        // object. The formatting will be controlled
        // via a command line flag in the future.
        const doFormatJson = true;
        const stringify = (input) => {
            if (doFormatJson) {
                return JSON.stringify(input, null, 2);
            }
            return JSON.stringify(input);
        };
        // A function to write a JSON string to a file, if
        // the JSON string does not represent an empty
        // object, and if the file can be written.
        const writeJsonFileOptional = (jsonString, fileName) => {
            if (jsonString === "{}") {
                return;
            }
            if (!ToolsMain.canWrite(fileName, force)) {
                console.log(`Cannot write ${fileName}`);
                return;
            }
            console.log(`Writing ${fileName}`);
            fs_1.default.writeFileSync(fileName, Buffer.from(jsonString));
        };
        // A function to write a buffer to a file, if
        // the buffer is not empty, and if the file
        // can be written.
        const writeFileOptional = (buffer, fileName) => {
            if (buffer.length === 0) {
                return;
            }
            if (!ToolsMain.canWrite(fileName, force)) {
                console.log(`Cannot write ${fileName}`);
                return;
            }
            console.log(`Writing ${fileName}`);
            fs_1.default.writeFileSync(fileName, buffer);
        };
        // Read the buffer and its magic header
        const magic = Buffers_1.Buffers.getMagicString(inputBuffer, 0);
        if (magic === "b3dm" || magic === "i3dm" || magic === "pnts") {
            // Handle the basic legacy tile formats
            const tileDataLayout = TileDataLayouts_1.TileDataLayouts.create(inputBuffer);
            const tileData = TileFormats_1.TileFormats.extractTileData(inputBuffer, tileDataLayout);
            // Create the JSON strings for the layout information,
            // feature table, batch table, and the GLB JSON
            const layoutJsonString = stringify(tileDataLayout);
            const featureTableJsonString = stringify(tileData.featureTable.json);
            const batchTableJsonString = stringify(tileData.batchTable.json);
            let glbJsonString = "{}";
            if (tileData.payload.length !== 0) {
                const glbJsonBuffer = GtlfUtilities_1.GltfUtilities.extractJsonFromGlb(tileData.payload);
                glbJsonString = glbJsonBuffer.toString();
            }
            if (doFormatJson) {
                const glbJson = JSON.parse(glbJsonString);
                glbJsonString = stringify(glbJson);
            }
            // Determine the output file names. They are files in the
            // output directory, prefixed with the name of the input
            // file, and with suffixes that indicate the actual contents
            const outputBaseName = Paths_1.Paths.resolve(outputDirectoryName, inputBaseName);
            const layoutFileName = outputBaseName + ".layout.json";
            const featureTableJsonFileName = outputBaseName + ".featureTable.json";
            const batchTableJsonFileName = outputBaseName + ".batchTable.json";
            const glbFileName = outputBaseName + ".glb";
            const glbJsonFileName = outputBaseName + ".glb.json";
            // Write all output files
            Paths_1.Paths.ensureDirectoryExists(outputDirectoryName);
            writeJsonFileOptional(layoutJsonString, layoutFileName);
            writeFileOptional(tileData.payload, glbFileName);
            writeJsonFileOptional(featureTableJsonString, featureTableJsonFileName);
            writeJsonFileOptional(batchTableJsonString, batchTableJsonFileName);
            writeJsonFileOptional(glbJsonString, glbJsonFileName);
        }
        else if (magic === "cmpt") {
            // Handle composite tiles
            const compositeTileData = TileFormats_1.TileFormats.readCompositeTileData(inputBuffer);
            const n = compositeTileData.innerTileBuffers.length;
            for (let i = 0; i < n; i++) {
                const innerTileDataBuffer = compositeTileData.innerTileBuffers[i];
                const innerTileBaseName = inputBaseName + ".inner[" + i + "]";
                ToolsMain.analyzeInternal(innerTileBaseName, innerTileDataBuffer, outputDirectoryName, force);
            }
        }
        else if (magic === "glTF") {
            // Handle GLB files
            let glbJsonString = "{}";
            const glbJsonBuffer = GtlfUtilities_1.GltfUtilities.extractJsonFromGlb(inputBuffer);
            glbJsonString = glbJsonBuffer.toString();
            if (doFormatJson) {
                const glbJson = JSON.parse(glbJsonString);
                glbJsonString = stringify(glbJson);
            }
            const outputBaseName = Paths_1.Paths.resolve(outputDirectoryName, inputBaseName);
            const glbJsonFileName = outputBaseName + ".glb.json";
            Paths_1.Paths.ensureDirectoryExists(outputDirectoryName);
            writeJsonFileOptional(glbJsonString, glbJsonFileName);
        }
    }
    static createGzipPipelineJson(input, output, tilesOnly) {
        let includedContentTypes = undefined;
        const excludedContentTypes = undefined;
        if (tilesOnly === true) {
            includedContentTypes = [
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_B3DM,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_I3DM,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_PNTS,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_CMPT,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_VCTR,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GEOM,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLB,
                ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLTF,
            ];
        }
        const tilesetStageJson = {
            name: "gzip",
            includedContentTypes: includedContentTypes,
            excludedContentTypes: excludedContentTypes,
        };
        const pipelineJson = {
            input: input,
            output: output,
            tilesetStages: [tilesetStageJson],
        };
        return pipelineJson;
    }
    static async gzip(input, output, force, tilesOnly) {
        ToolsMain.ensureCanWrite(output, force);
        const pipelineJson = ToolsMain.createGzipPipelineJson(input, output, tilesOnly);
        const pipeline = Pipelines_1.Pipelines.createPipeline(pipelineJson);
        await PipelineExecutor_1.PipelineExecutor.executePipeline(pipeline, force);
    }
    static createUngzipPipelineJson(input, output) {
        const contentStageJson = {
            name: "ungzip",
        };
        const pipelineJson = {
            input: input,
            output: output,
            tilesetStages: [
                {
                    name: "ungzip",
                    contentStages: [contentStageJson],
                },
            ],
        };
        return pipelineJson;
    }
    static async ungzip(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        const pipelineJson = ToolsMain.createUngzipPipelineJson(input, output);
        const pipeline = Pipelines_1.Pipelines.createPipeline(pipelineJson);
        await PipelineExecutor_1.PipelineExecutor.executePipeline(pipeline, force);
    }
    static async convert(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        const inputExtension = path_1.default.extname(input).toLowerCase();
        if (inputExtension === ".zip") {
            await ZipToPackage_1.ZipToPackage.convert(input, output, force);
        }
        else {
            const tilesetSource = TilesetSources_1.TilesetSources.createAndOpen(input);
            const tilesetTarget = TilesetTargets_1.TilesetTargets.createAndBegin(output, force);
            const keys = tilesetSource.getKeys();
            for (const key of keys) {
                const content = tilesetSource.getValue(key);
                if (content) {
                    tilesetTarget.addEntry(key, content);
                }
            }
            tilesetSource.close();
            await tilesetTarget.end();
        }
    }
    static async combine(input, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        await Tilesets_1.Tilesets.combine(input, output, force);
    }
    static async upgrade(input, output, force, gltfUpgradeOptions) {
        ToolsMain.ensureCanWrite(output, force);
        await Tilesets_1.Tilesets.upgrade(input, output, force, gltfUpgradeOptions);
    }
    static async merge(inputs, output, force) {
        ToolsMain.ensureCanWrite(output, force);
        await Tilesets_1.Tilesets.merge(inputs, output, force);
    }
    static async pipeline(input, force) {
        const pipelineJsonBuffer = fs_1.default.readFileSync(input);
        const pipelineJson = JSON.parse(pipelineJsonBuffer.toString());
        const pipeline = Pipelines_1.Pipelines.createPipeline(pipelineJson);
        await PipelineExecutor_1.PipelineExecutor.executePipeline(pipeline, force);
    }
    /**
     * Returns whether the specified file can be written.
     *
     * This is the case when `force` is `true`, or when it does not
     * exist yet.
     *
     * @param fileName - The file name
     * @param force The 'force' flag state from the command line
     * @returns Whether the file can be written
     */
    static canWrite(fileName, force) {
        if (force) {
            return true;
        }
        if (!fs_1.default.existsSync(fileName)) {
            return true;
        }
        return false;
    }
    /**
     * Ensures that the specified file can be written, and throws
     * a `DeveloperError` otherwise.
     *
     * @param fileName - The file name
     * @param force The 'force' flag state from the command line
     * @returns Whether the file can be written
     * @throws DeveloperError When the file exists and `force` was `false`.
     */
    static ensureCanWrite(fileName, force) {
        if (ToolsMain.canWrite(fileName, force)) {
            return true;
        }
        throw new DeveloperError_1.DeveloperError(`File ${fileName} already exists. Specify -f or --force to overwrite existing files.`);
    }
}
exports.ToolsMain = ToolsMain;
