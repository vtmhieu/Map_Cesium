"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetCombiner = void 0;
const path_1 = __importDefault(require("path"));
const Paths_1 = require("../base/Paths");
const DeveloperError_1 = require("../base/DeveloperError");
const TilesetError_1 = require("../tilesetData/TilesetError");
const TilesetSources_1 = require("../tilesetData/TilesetSources");
const TilesetTargets_1 = require("../tilesetData/TilesetTargets");
const Tiles_1 = require("../tilesets/Tiles");
const Tilesets_1 = require("../tilesets/Tilesets");
const BufferedContentData_1 = require("../contentTypes/BufferedContentData");
/**
 * A class for combining external tileset of a given tileset, to
 * create a new, combined tileset.
 */
class TilesetCombiner {
    /**
     * Creates a new instance
     *
     * @param externalTilesetDetector - The predicate that is used to
     * detect whether something is an external tileset
     */
    constructor(externalTilesetDetector) {
        this.externalTilesetDetector = externalTilesetDetector;
        this.externalTilesetFileNames = [];
    }
    /**
     * Combines ("inlines") the external tilesets that are referred to by
     * the given source tileset, and writes the result to the given target.
     *
     * @param tilesetSourceName - The tileset source name
     * @param tilesetTargetName - The tileset target name
     * @param overwrite Whether the target should be overwritten if
     * it already exists
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed,
     * or when the output already exists and `overwrite` was `false`.
     */
    async combine(tilesetSourceName, tilesetTargetName, overwrite) {
        const tilesetSource = TilesetSources_1.TilesetSources.createAndOpen(tilesetSourceName);
        const tilesetTarget = TilesetTargets_1.TilesetTargets.createAndBegin(tilesetTargetName, overwrite);
        this.tilesetSource = tilesetSource;
        this.tilesetTarget = tilesetTarget;
        const tilesetSourceJsonFileName = Tilesets_1.Tilesets.determineTilesetJsonFileName(tilesetSourceName);
        const tilesetTargetJsonFileName = Tilesets_1.Tilesets.determineTilesetJsonFileName(tilesetTargetName);
        await this.combineInternal(tilesetSource, tilesetSourceJsonFileName, tilesetTarget, tilesetTargetJsonFileName);
        tilesetSource.close();
        await tilesetTarget.end();
        this.tilesetSource = undefined;
        this.tilesetTarget = undefined;
    }
    /**
     * Combines all external tilesets in the given source, and writes
     * the result into the given target.
     *
     * The caller is responsible for opening and closing the given
     * source and target.
     *
     * @param tilesetSource The tileset source
     * @param tilesetSourceJsonFileName The name of the top-level tileset in
     * the given source (usually `tileset.json`).
     * @param tilesetTarget The tileset target
     * @param tilesetTargetJsonFileName The name of the top-level tileset in
     * the given target (usually `tileset.json`).
     * @returns A promise that resolves when the process is finished.
     * @throws TilesetError When the input tileset file can not be
     * found
     * @throws TilesetError If `open` was not called on the
     * input, or `begin` was not called on the output.
     */
    async combineInternal(tilesetSource, tilesetSourceJsonFileName, tilesetTarget, tilesetTargetJsonFileName) {
        const tilesetJsonBuffer = tilesetSource.getValue(tilesetSourceJsonFileName);
        if (!tilesetJsonBuffer) {
            const message = `No ${tilesetSourceJsonFileName} found in input`;
            throw new TilesetError_1.TilesetError(message);
        }
        const tileset = JSON.parse(tilesetJsonBuffer.toString());
        this.externalTilesetFileNames.length = 0;
        await this.combineTilesetsInternal(".", tileset, undefined);
        this.copyResources();
        const combinedTilesetJsonString = JSON.stringify(tileset, null, 2);
        const combinedTilesetJsonBuffer = Buffer.from(combinedTilesetJsonString);
        tilesetTarget.addEntry(tilesetTargetJsonFileName, combinedTilesetJsonBuffer);
    }
    /**
     * Internal method to combine the given tileset.
     *
     * This is called with the source tileset, and then with every
     * external tileset that is encountered.
     *
     * The current directory is tracked as a directory relative to the
     * root of the original source tileset, leading to the directory
     * that contains the current tileset.
     *
     * @param currentDirectory - The current directory
     * @param tileset - The current tileset
     * @param parentTile - The optional parent tile
     */
    async combineTilesetsInternal(currentDirectory, tileset, parentTile) {
        const root = tileset.root;
        if (parentTile) {
            parentTile.content = root.content;
            parentTile.contents = root.contents;
            parentTile.children = root.children;
        }
        await Tiles_1.Tiles.traverseExplicit(root, async (tilePath) => {
            const tile = tilePath[tilePath.length - 1];
            await this.combineTileInternal(currentDirectory, tile);
            return true;
        });
    }
    /**
     * This is called for each (explicit) tile in the source tileset and
     * its external tilesets, and calls `combineContentInternal`
     * for each content, in order to process the external tilesets
     * that the contents may contain, and to update tile content URLs
     * for the combined output.
     *
     * @param currentDirectory - The current directory (see `combineTilesetsInternal`)
     * @param tile - The current tile
     */
    async combineTileInternal(currentDirectory, tile) {
        if (tile.content) {
            await this.combineContentInternal(currentDirectory, tile, tile.content);
        }
        else if (tile.contents) {
            for (const content of tile.contents) {
                await this.combineContentInternal(currentDirectory, tile, content);
            }
        }
    }
    /**
     * This is called for each content of each tile of the source tileset and
     * all of its external tilesets.
     *
     * If the given content points to an external tileset, it is inlined
     * by calling `combineTilesetsInternal` with the directory and JSON of the
     * external tileset.
     *
     * Otherwise, the URL of the content is updated to be relative to
     * the root of the resulting combined tileset.
     *
     * @param currentDirectory - The current directory (see `combineTilesetsInternal`)
     * @param tile - The current tile
     * @param content - The current tile content
     */
    async combineContentInternal(currentDirectory, tile, content) {
        if (!this.tilesetSource || !this.tilesetTarget) {
            throw new DeveloperError_1.DeveloperError("The source and target must be defined");
        }
        const contentUri = content.uri;
        if (!contentUri) {
            // This is the case for legacy data (including some of the
            // original spec data), so handle this case explicitly here.
            throw new TilesetError_1.TilesetError("Content does not have a URI");
        }
        const externalFileName = Paths_1.Paths.join(currentDirectory, contentUri);
        const externalFileBuffer = this.tilesetSource.getValue(externalFileName);
        if (!externalFileBuffer) {
            throw new TilesetError_1.TilesetError(`No data found for ${externalFileName}`);
        }
        const contentData = new BufferedContentData_1.BufferedContentData(contentUri, externalFileBuffer);
        const isTileset = await this.externalTilesetDetector(contentData);
        if (!isTileset) {
            // When the data is not an external tileset, then just update
            // the content URI to point to the path that the content data
            // will end up in
            const newUri = Paths_1.Paths.relativize(".", externalFileName);
            content.uri = newUri;
        }
        else {
            // When the data is an external tileset, recursively combine
            // ("inline") that tileset, and insert its content, contents
            // and children into the current tile
            this.externalTilesetFileNames.push(externalFileName);
            const externalTilesetDirectory = path_1.default.dirname(externalFileName);
            const externalTilesetBuffer = this.tilesetSource.getValue(externalFileName);
            if (!externalTilesetBuffer) {
                throw new TilesetError_1.TilesetError(`Could not obtain data for external ` +
                    `tileset file ${externalFileName}`);
            }
            const externalTileset = JSON.parse(externalTilesetBuffer.toString());
            await this.combineTilesetsInternal(externalTilesetDirectory, externalTileset, tile);
        }
    }
    /**
     * Copy all elements from the tileset source to the tileset target,
     * except for the ones that have been determined to be external
     * tilesets.
     *
     * This is supposed to be called when the `tilesetSource` and
     * `tilesetTarget` are defined, and BEFORE the entry for the
     * combined tileset JSON is added to the target, because that
     * entry might overwrite an existing one.
     */
    copyResources() {
        if (!this.tilesetSource || !this.tilesetTarget) {
            throw new DeveloperError_1.DeveloperError("The source and target must be defined");
        }
        const entries = TilesetSources_1.TilesetSources.getEntries(this.tilesetSource);
        for (const entry of entries) {
            const key = entry.key;
            if (this.externalTilesetFileNames.includes(key)) {
                continue;
            }
            this.tilesetTarget.addEntry(key, entry.value);
        }
    }
}
exports.TilesetCombiner = TilesetCombiner;
