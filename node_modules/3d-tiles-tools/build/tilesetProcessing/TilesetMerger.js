"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetMerger = void 0;
const path_1 = __importDefault(require("path"));
const cesium_1 = require("cesium");
const Paths_1 = require("../base/Paths");
const DeveloperError_1 = require("../base/DeveloperError");
const TilesetError_1 = require("../tilesetData/TilesetError");
const TilesetSources_1 = require("../tilesetData/TilesetSources");
const TilesetTargets_1 = require("../tilesetData/TilesetTargets");
const Tilesets_1 = require("../tilesets/Tilesets");
/**
 * A class for merging multiple tilesets, to create a tileset that refers
 * to the merged ones as external tilesets.
 */
class TilesetMerger {
    /**
     * Creates a new instance
     */
    constructor() {
        this.tilesetSources = [];
        this.tilesetSourceJsonFileNames = [];
        this.tilesetSourceIdentifiers = [];
    }
    /**
     * Merges the tileset from the specified sources into one tileset
     * that refers to the sources as external ones, and writes the
     * result into the given target.
     *
     * @param tilesetSourceNames - The tileset source names
     * @param tilesetTargetName - The tileset target name
     * @param overwrite - Whether target files should be overwritten
     * @returns A promise that resolves when the process is finished
     * @throws TilesetError When the input could not be processed
     * @throws TilesetError When the output already exists
     * and `overwrite` was `false`.
     */
    async merge(tilesetSourceNames, tilesetTargetName, overwrite) {
        // Create the sources and target
        for (const tilesetSourceName of tilesetSourceNames) {
            // Determine the name of the file that contains the tileset JSON data
            const tilesetSourceJsonFileName = Tilesets_1.Tilesets.determineTilesetJsonFileName(tilesetSourceName);
            // Determine an "identifier" for the tileset source
            // (see `tilesetSourceIdentifiers` for details)
            let tilesetSourceDirectoryName;
            if (Paths_1.Paths.isDirectory(tilesetSourceName)) {
                tilesetSourceDirectoryName = path_1.default.basename(tilesetSourceName);
            }
            else {
                tilesetSourceDirectoryName = path_1.default.basename(path_1.default.dirname(tilesetSourceName));
            }
            const tilesetSourceIdentifier = TilesetMerger.createIdentifier(tilesetSourceDirectoryName, this.tilesetSourceIdentifiers);
            const tilesetSource = TilesetSources_1.TilesetSources.createAndOpen(tilesetSourceName);
            this.tilesetSources.push(tilesetSource);
            this.tilesetSourceJsonFileNames.push(tilesetSourceJsonFileName);
            this.tilesetSourceIdentifiers.push(tilesetSourceIdentifier);
        }
        this.tilesetTargetJsonFileName =
            Tilesets_1.Tilesets.determineTilesetJsonFileName(tilesetTargetName);
        this.tilesetTarget = TilesetTargets_1.TilesetTargets.createAndBegin(tilesetTargetName, overwrite);
        // Perform the actual merge
        this.mergeInternal();
        // Clean up by closing the sources and the target
        for (const tilesetSource of this.tilesetSources) {
            tilesetSource.close();
        }
        await this.tilesetTarget.end();
        this.tilesetSources.length = 0;
        this.tilesetSourceIdentifiers.length = 0;
        this.tilesetTarget = undefined;
        this.tilesetTargetJsonFileName = undefined;
    }
    /**
     * Internal method for `merge`
     */
    mergeInternal() {
        if (this.tilesetSources.length == 0 ||
            !this.tilesetTarget ||
            !this.tilesetTargetJsonFileName) {
            throw new DeveloperError_1.DeveloperError("The sources and target must be defined");
        }
        // Parse the Tileset objects from all sources
        const tilesets = [];
        const length = this.tilesetSources.length;
        for (let i = 0; i < length; ++i) {
            const tilesetSource = this.tilesetSources[i];
            const tilesetSourceJsonFileName = this.tilesetSourceJsonFileNames[i];
            const tilesetJsonBuffer = tilesetSource.getValue(tilesetSourceJsonFileName);
            if (!tilesetJsonBuffer) {
                const message = `No ${tilesetSourceJsonFileName} found in input`;
                throw new TilesetError_1.TilesetError(message);
            }
            const tileset = JSON.parse(tilesetJsonBuffer.toString());
            tilesets.push(tileset);
        }
        // Derive the information for the merged tileset
        const geometricError = TilesetMerger.getMergedGeometricError(tilesets);
        const sphere = TilesetMerger.getMergedSphere(tilesets);
        const children = TilesetMerger.getChildren(tilesets, this.tilesetSourceIdentifiers, this.tilesetSourceJsonFileNames);
        const mergedTileset = {
            asset: {
                version: "1.1",
            },
            geometricError: geometricError,
            root: {
                boundingVolume: {
                    sphere: sphere,
                },
                refine: "ADD",
                geometricError: geometricError,
                children: children,
            },
        };
        // Write the merged tileset into the target
        const mergedTilesetJson = JSON.stringify(mergedTileset, null, 2);
        const mergedTilesetBuffer = Buffer.from(mergedTilesetJson);
        this.tilesetTarget.addEntry(this.tilesetTargetJsonFileName, mergedTilesetBuffer);
        // Copy the resources from the sources to the target
        this.copyResources();
    }
    /**
     * Copy the resources from the source tilesets into the target.
     *
     * This will obtain the entries of all sources, and add them
     * to the target, adding the `tilesetSourceIdentifier` to the
     * path for disambiguation.
     */
    copyResources() {
        if (this.tilesetSources.length == 0 || !this.tilesetTarget) {
            throw new DeveloperError_1.DeveloperError("The sources and target must be defined");
        }
        const length = this.tilesetSources.length;
        for (let i = 0; i < length; ++i) {
            const tilesetSource = this.tilesetSources[i];
            const tilesetSourceIdentifier = this.tilesetSourceIdentifiers[i];
            const sourceKeys = tilesetSource.getKeys();
            for (const sourceKey of sourceKeys) {
                const value = tilesetSource.getValue(sourceKey);
                const targetKey = tilesetSourceIdentifier + "/" + sourceKey;
                if (value) {
                    this.tilesetTarget.addEntry(targetKey, value);
                }
            }
        }
    }
    /**
     * Creates an identifier that does not exist yet.
     *
     * If the given prefix is not yet contained in the given list,
     * then it is returned. Otherwise, it is made "unique" in an
     * unspecified way, and then returned.
     *
     * This does NOT add the new identifier to the given list!
     *
     * @param prefix - The prefix
     * @param existingIdentifiers - The existing identifiers
     * @returns The new identifier
     */
    static createIdentifier(prefix, existingIdentifiers) {
        let identifier = prefix;
        let counter = 0;
        for (;;) {
            if (!existingIdentifiers.includes(identifier)) {
                return identifier;
            }
            identifier = prefix + "-" + counter;
            counter++;
        }
    }
    //========================================================================
    // The following functions are ported from the `merge-tilesets` branch
    // at https://github.com/CesiumGS/3d-tiles-tools/blob/d7e76e59022fc5e5aa4b848730ec9f8f4dea6d4e/tools/lib/mergeTilesets.js
    // with slight modification of 'getChildren' for disambiguation...
    static getChildren(tilesets, tilesetSourceIdentifiers, tilesetJsonFileNames) {
        const length = tilesets.length;
        const children = new Array(length);
        for (let i = 0; i < length; ++i) {
            const tilesetJsonFileName = tilesetJsonFileNames[i];
            const tilesetSourceIdentifier = tilesetSourceIdentifiers[i];
            const tilesetUrl = Paths_1.Paths.join(tilesetSourceIdentifier, tilesetJsonFileName);
            children[i] = tilesets[i].root;
            children[i].content = {
                uri: tilesetUrl,
            };
            children[i].boundingVolume = {
                sphere: TilesetMerger.getBoundingSphere(tilesets[i]),
            };
            delete children[i].children;
            delete children[i].transform;
        }
        return children;
    }
    static getMergedGeometricError(tilesets) {
        let geometricError = 0.0;
        const length = tilesets.length;
        for (let i = 0; i < length; ++i) {
            geometricError = Math.max(geometricError, tilesets[i].geometricError);
        }
        return geometricError;
    }
    static getBoundingSphere(tileset) {
        const root = tileset.root;
        let transform = cesium_1.Matrix4.IDENTITY;
        if (root.transform) {
            transform = cesium_1.Matrix4.fromArray(root.transform);
        }
        const boundingVolume = root.boundingVolume;
        let boundingSphere;
        if (boundingVolume.sphere) {
            boundingSphere = TilesetMerger.createBoundingSphereFromSphere(boundingVolume.sphere, transform);
        }
        else if (boundingVolume.region) {
            boundingSphere = TilesetMerger.createBoundingSphereFromRegion(boundingVolume.region);
        }
        else if (boundingVolume.box) {
            boundingSphere = TilesetMerger.createBoundingSphereFromBox(boundingVolume.box, transform);
        }
        else {
            throw new TilesetError_1.TilesetError("No bounding volume found in root tile");
        }
        const center = boundingSphere.center;
        const radius = boundingSphere.radius;
        return [center.x, center.y, center.z, radius];
    }
    static getMergedSphere(tilesets) {
        const length = tilesets.length;
        const boundingSpheres = new Array(length);
        for (let i = 0; i < length; ++i) {
            boundingSpheres[i] = cesium_1.BoundingSphere.unpack(TilesetMerger.getBoundingSphere(tilesets[i]));
        }
        const boundingSphere = cesium_1.BoundingSphere.fromBoundingSpheres(boundingSpheres);
        const center = boundingSphere.center;
        const radius = boundingSphere.radius;
        return [center.x, center.y, center.z, radius];
    }
    static createBoundingSphereFromBox(box, transform) {
        let center = cesium_1.Cartesian3.fromElements(box[0], box[1], box[2]);
        let halfAxes = cesium_1.Matrix3.fromArray(box, 3);
        // Find the transformed center and halfAxes
        center = cesium_1.Matrix4.multiplyByPoint(transform, center, center);
        const rotationScale = cesium_1.Matrix4.getMatrix3(transform, new cesium_1.Matrix3());
        halfAxes = cesium_1.Matrix3.multiply(rotationScale, halfAxes, halfAxes);
        const orientedBoundingBox = new cesium_1.OrientedBoundingBox(center, halfAxes);
        return cesium_1.BoundingSphere.fromOrientedBoundingBox(orientedBoundingBox);
    }
    static createBoundingSphereFromRegion(region) {
        const rectangle = cesium_1.Rectangle.unpack(region);
        const minimumHeight = region[4];
        const maximumHeight = region[5];
        const orientedBoundingBox = cesium_1.OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight);
        return cesium_1.BoundingSphere.fromOrientedBoundingBox(orientedBoundingBox);
    }
    static createBoundingSphereFromSphere(sphere, transform) {
        let center = cesium_1.Cartesian3.fromElements(sphere[0], sphere[1], sphere[2]);
        let radius = sphere[3];
        // Find the transformed center and radius
        center = cesium_1.Matrix4.multiplyByPoint(transform, center, center);
        const scale = cesium_1.Matrix4.getScale(transform, new cesium_1.Cartesian3());
        const uniformScale = cesium_1.Cartesian3.maximumComponent(scale);
        radius *= uniformScale;
        return new cesium_1.BoundingSphere(center, radius);
    }
}
exports.TilesetMerger = TilesetMerger;
