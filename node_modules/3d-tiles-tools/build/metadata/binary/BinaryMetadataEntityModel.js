"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryMetadataEntityModel = void 0;
const defined_1 = require("../../base/defined");
const MetadataValues_1 = require("../MetadataValues");
const MetadataError_1 = require("../MetadataError");
/**
 * Implementation of a `MetadataEntityModel` that is backed by binary
 * data (specifically, by a `PropertyTableModel`)
 *
 * @internal
 */
class BinaryMetadataEntityModel {
    constructor(propertyTableModel, entityIndex, semanticToPropertyId) {
        this._propertyTableModel = propertyTableModel;
        this._entityIndex = entityIndex;
        this._semanticToPropertyId = semanticToPropertyId;
    }
    /** {@inheritDoc MetadataEntityModel.getPropertyValue} */
    getPropertyValue(propertyId) {
        const propertyTableModel = this._propertyTableModel;
        const classProperty = propertyTableModel.getClassProperty(propertyId);
        if (!(0, defined_1.defined)(classProperty)) {
            const message = `The class does not define a property ${propertyId}`;
            throw new MetadataError_1.MetadataError(message);
        }
        const propertyTableProperty = propertyTableModel.getPropertyTableProperty(propertyId);
        if (!(0, defined_1.defined)(propertyTableProperty)) {
            const message = `The property table does not define a property ${propertyId}`;
            throw new MetadataError_1.MetadataError(message);
        }
        const propertyModel = propertyTableModel.getPropertyModel(propertyId);
        if (!propertyModel) {
            const message = `The property table does not ` +
                `define a property model for ${propertyId}`;
            throw new MetadataError_1.MetadataError(message);
        }
        const value = propertyModel.getPropertyValue(this._entityIndex);
        const offsetOverride = propertyTableProperty.offset;
        const scaleOverride = propertyTableProperty.scale;
        const processedValue = MetadataValues_1.MetadataValues.processValue(classProperty, offsetOverride, scaleOverride, value);
        return processedValue;
    }
    /** {@inheritDoc MetadataEntityModel.getPropertyValueBySemantic} */
    getPropertyValueBySemantic(semantic) {
        const propertyId = this._semanticToPropertyId[semantic];
        if (!(0, defined_1.defined)(propertyId)) {
            return undefined;
        }
        return this.getPropertyValue(propertyId);
    }
}
exports.BinaryMetadataEntityModel = BinaryMetadataEntityModel;
