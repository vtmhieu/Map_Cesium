"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataValues = void 0;
const defined_1 = require("../base/defined");
const MetadataComponentTypes_1 = require("./MetadataComponentTypes");
const ArrayValues_1 = require("./ArrayValues");
/**
 * Internal methods related to metadata values.
 *
 * @internal
 */
class MetadataValues {
    /**
     * Processes the given "raw" value that was obtained for a metadata
     * property (e.g. from the JSON representation), and returns the
     * processed value according to the type definition that is given
     * by the given class property.
     *
     * If the type defines a `noData` value, and the given value
     * is the `noData` value, then the `default` value of the type
     * is returned.
     *
     * If the type defines the value to be `normalized`, then the
     * normalization is applied to the given values.
     *
     * If the type defines an `offset`, then the offset is added
     * to the value.
     *
     * If the type defines a `scale`, then this is multiplied
     * with the value.
     *
     * @param classProperty - The `ClassProperty`
     * @param offsetOverride -: An optional override for the
     * `offset` of the `ClassProperty`. If this is defined, then
     * it will be used instead of the one from the class property.
     * @param scaleOverride -: An optional override for the
     * `scale` of the `ClassProperty`. If this is defined, then
     * it will be used instead of the one from the class property.
     * @param value - The value
     * @returns The processed value
     */
    static processValue(classProperty, offsetOverride, scaleOverride, value) {
        const noData = classProperty.noData;
        const defaultValue = classProperty.default;
        if ((0, defined_1.defined)(noData)) {
            if (ArrayValues_1.ArrayValues.deepEquals(value, noData)) {
                return ArrayValues_1.ArrayValues.deepClone(defaultValue);
            }
        }
        if (!(0, defined_1.defined)(value)) {
            return ArrayValues_1.ArrayValues.deepClone(defaultValue);
        }
        value = ArrayValues_1.ArrayValues.deepClone(value);
        if (classProperty.normalized === true) {
            const componentType = classProperty.componentType;
            value = MetadataValues.normalize(value, componentType);
        }
        const offset = (0, defined_1.defined)(offsetOverride)
            ? offsetOverride
            : classProperty.offset;
        const scale = (0, defined_1.defined)(scaleOverride) ? scaleOverride : classProperty.scale;
        if ((0, defined_1.defined)(scale)) {
            value = ArrayValues_1.ArrayValues.deepMultiply(value, scale);
        }
        if ((0, defined_1.defined)(offset)) {
            value = ArrayValues_1.ArrayValues.deepAdd(value, offset);
        }
        return value;
    }
    /**
     * Normalize the given input value, based on the given component type.
     *
     * If example, the value of `255` for `UINT8` will be normalized to `1.0`.
     *
     * @param value - The input value
     * @param componentType - The component type
     * @returns The normalized value
     */
    static normalize(value, componentType) {
        if (!Array.isArray(value)) {
            return MetadataComponentTypes_1.MetadataComponentTypes.normalize(value, componentType);
        }
        for (let i = 0; i < value.length; i++) {
            value[i] = MetadataValues.normalize(value[i], componentType);
        }
        return value;
    }
}
exports.MetadataValues = MetadataValues;
