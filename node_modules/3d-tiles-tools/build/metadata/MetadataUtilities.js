"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataUtilities = void 0;
const defined_1 = require("../base/defined");
/**
 * Internal utilities related to metadata
 *
 * @internal
 */
class MetadataUtilities {
    /**
     * Computes the `BianaryEnumInfo` that summarizes information
     * about the binary representation of `MetadataEnum` values
     * from the given schema.
     *
     * @param schema - The metadata `Schema`
     * @returns The `BinaryEnumInfo`
     */
    static computeBinaryEnumInfo(schema) {
        const binaryEnumInfo = {
            enumValueTypes: MetadataUtilities.computeEnumValueTypes(schema),
            enumValueNameValues: MetadataUtilities.computeEnumValueNameValues(schema),
        };
        return binaryEnumInfo;
    }
    /**
     * Computes a mapping from enum type names to the `valueType` that
     * the respective `MetdataEnum` has (defaulting to `UINT16` if it
     * did not define one)
     *
     * @param schema - The metadata `Schema`
     * @returns The mapping from enum type names to enum value types
     */
    static computeEnumValueTypes(schema) {
        const enumValueTypes = {};
        const enums = schema.enums;
        if (enums) {
            for (const enumName of Object.keys(enums)) {
                const metadataEnum = enums[enumName];
                const valueType = metadataEnum.valueType ?? "UINT16";
                enumValueTypes[enumName] = valueType;
            }
        }
        return enumValueTypes;
    }
    /**
     * Computes a mapping from enum type names to the dictionaries
     * that map the enum values names to the enum value values.
     *
     * @param schema - The metadata `Schema`
     * @returns The mapping from enum type names to dictionaries
     */
    static computeEnumValueNameValues(schema) {
        const enumValueNameValues = {};
        const enums = schema.enums;
        if (enums) {
            for (const enumName of Object.keys(enums)) {
                const metadataEnum = enums[enumName];
                const nameValues = {};
                for (let i = 0; i < metadataEnum.values.length; i++) {
                    const enumValue = metadataEnum.values[i];
                    const value = enumValue.value;
                    const name = enumValue.name;
                    nameValues[name] = value;
                }
                enumValueNameValues[enumName] = nameValues;
            }
        }
        return enumValueNameValues;
    }
    /**
     * Internal method to obtain the names of enum values for the
     * given property.
     *
     * This tries to return the list of all
     * `schema.enums[classProperty.enumType].values[i].name`
     * values, returning the empty list if the property does not
     * have an enum type or any element is not defined.
     *
     * @param classProperty - The `ClassProperty`
     * @param schema - The `Schema`
     * @returns The enum value names
     */
    static obtainEnumValueNames(classProperty, schema) {
        const type = classProperty.type;
        if (type !== "ENUM") {
            return [];
        }
        const enumType = classProperty.enumType;
        if (!(0, defined_1.defined)(enumType)) {
            return [];
        }
        const enums = schema.enums;
        if (!enums) {
            return [];
        }
        const theEnum = enums[enumType];
        if (!(0, defined_1.defined)(theEnum)) {
            return [];
        }
        const enumValues = theEnum.values;
        if (!enumValues) {
            return [];
        }
        const enumValueNames = enumValues.map((e) => e.name);
        return enumValueNames;
    }
}
exports.MetadataUtilities = MetadataUtilities;
