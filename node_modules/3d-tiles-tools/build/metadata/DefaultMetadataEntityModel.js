"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMetadataEntityModel = void 0;
const defined_1 = require("../base/defined");
const MetadataValues_1 = require("./MetadataValues");
const MetadataError_1 = require("./MetadataError");
/**
 * Default implementation of a `MetadataEntityModel` that is backed
 * by the JSON representation of the metadata.
 *
 * (The JSON representation are just the `metadataEntity.properties`
 * from the input JSON)
 *
 * @internal
 */
class DefaultMetadataEntityModel {
    constructor(metadataClass, semanticToPropertyId, json) {
        this._metadataClass = metadataClass;
        this._semanticToPropertyId = semanticToPropertyId;
        this._json = json;
    }
    /** {@inheritDoc MetadataEntityModel.getPropertyValue} */
    getPropertyValue(propertyId) {
        const properties = this._metadataClass.properties;
        if (!properties) {
            throw new MetadataError_1.MetadataError(`Metadata class does not have any properties`);
        }
        const property = properties[propertyId];
        if (!property) {
            throw new MetadataError_1.MetadataError(`Metadata class does not have property ${propertyId}`);
        }
        const value = this._json[propertyId];
        const offset = this._json.offset;
        const scale = this._json.scale;
        return MetadataValues_1.MetadataValues.processValue(property, offset, scale, value);
    }
    /** {@inheritDoc MetadataEntityModel.getPropertyValueBySemantic} */
    getPropertyValueBySemantic(semantic) {
        const propertyId = this._semanticToPropertyId[semantic];
        if (!(0, defined_1.defined)(propertyId)) {
            return undefined;
        }
        return this.getPropertyValue(propertyId);
    }
}
exports.DefaultMetadataEntityModel = DefaultMetadataEntityModel;
