/// <reference types="node" />
import { ContentData } from "./ContentData";
/**
 * A class for determining the type of data that a URI points to.
 *
 * The only public methods (for now) are `findType`, which
 * determines the type of data that is given as a URI and
 * a buffer, and `findContentDataType`, which returns the
 * string that describes the type of a `ContentData` object.
 *
 * @internal
 */
export declare class ContentDataTypeRegistry {
    /**
     * The list of types that have been registered.
     */
    private static readonly entries;
    /**
     * Whether the default content data types have already
     * been registered by calling 'registerDefaults'
     *
     * Note: This could be solved with a static initializer block, but the
     * unclear initialization order of the classes would make this brittle
     */
    private static _registeredDefaults;
    /**
     * Registers all default content data types
     */
    private static registerDefaults;
    /**
     * Tries to find the string that describes the type of the given data.
     * If the type of the data cannot be determined, then `undefined` is
     * returned.
     *
     * This is a convenience method for `findContentDataType`, for the
     * case that the data is already fully available as a buffer. If
     * the data should be fetched lazily, then `findContentDataType`
     * should be called with a `LazyContentData` object.
     *
     * @param uri - The URI of the data
     * @param data - the actual data
     * @returns The string, or `undefined`
     */
    static findType(uri: string, data: Buffer): Promise<string | undefined>;
    /**
     * Tries to find the string that describes the given content data
     * type. If the type of the content data cannot be determined,
     * then `undefined` is returned.
     *
     * The exact criteria for determining the data type are not specified.
     * It may, for example, be determined solely by a file extension of
     * the URI of the given content data, or by magic bytes in the data,
     * or by any other criterion.
     *
     * @param contentData - The `ContentData`
     * @returns The string, or `undefined`
     */
    static findContentDataType(contentData: ContentData): Promise<string | undefined>;
    /**
     * Creates a predicate that checks whether the magic header of
     * a ContentData (interpreted as ASCII characters) starts with
     * the given magic header string.
     *
     * @param magic - The magic header string
     * @returns The predicate
     */
    private static byMagicString;
    /**
     * Creates a predicate that checks whether the magic header of
     * a ContentData starts with the given bytes
     *
     * @param magic - The magic bytes
     * @returns The predicate
     */
    private static byMagicBytes;
    /**
     * Creates a predicate that checks whether the extension of
     * a ContentData matches the given extension (which should
     * include the '.' dot).
     *
     * @param extension - The extension
     * @returns The predicate
     */
    private static byExtension;
    /**
     * Creates a predicate that says whether a ContentData is
     * (probably) a tileset.
     *
     * @returns The predicate
     */
    private static byBeingTileset;
    /**
     * Creates a predicate that says whether a ContentData is
     * (probably) a glTF JSON.
     *
     * @returns The predicate
     */
    private static byBeingGltf;
    /**
     * Returns whether the given content data is probably a tileset.
     *
     * The exact conditions for this method returning `true` are
     * intentionally not specified.
     *
     * @param contentData - The content data
     * @returns Whether the content data is probably a tileset
     */
    private static isProbablyTileset;
    /**
     * Returns whether the given content data is probably a glTF
     * (not a GLB, but a glTF JSON).
     *
     * The exact conditions for this method returning `true` are
     * intentionally not specified.
     *
     * @param contentData - The content data
     * @returns Whether the content data is probably glTF
     */
    private static isProbablyGltf;
    /**
     * Registers a type name for `ContentData` that matches the given predicate.
     *
     * @param predicate - The predicate
     * @param type - The type
     * @throws DeveloperError If the given type was already registered
     */
    private static register;
}
//# sourceMappingURL=ContentDataTypeRegistry.d.ts.map