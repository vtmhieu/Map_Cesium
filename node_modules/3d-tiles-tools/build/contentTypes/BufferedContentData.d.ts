/// <reference types="node" />
import { ContentData } from "./ContentData";
/**
 * Implementation of the `ContentData` interface that stores
 * the full content data in a buffer.
 *
 * This could be completely synchronous. But every possibility
 * of anything being "async" causes the promises to be smeared
 * over all interfaces, through all call chains.
 *
 * @internal
 */
export declare class BufferedContentData implements ContentData {
    /**
     * Create content data from the given URI, assuming that it
     * is a file in the local file system.
     *
     * This will try to read the data from the given file, and
     * create a ContentData from that. If the data cannot be
     * read, a warning will be printed, and the method will
     * return a ContentData where `exists` returns `false`.
     *
     * @param uri - The URI
     * @returns The ContentData
     */
    static create(uri: string): ContentData;
    /**
     * The (relative) URI that was given in the constructor.
     */
    private readonly _uri;
    /**
     * The file extension from the URI, in lowercase,
     * including the `.` dot.
     */
    private readonly _extension;
    /**
     * The "magic header bytes" from the content data. These
     * are the first (up to) 4 bytes of the content data,
     * or the empty buffer if the content data could not
     * be resolved.
     */
    private readonly _magic;
    /**
     * The content data, or `null` if the data could not
     * be resolved.
     */
    private readonly _data;
    /**
     * The object that was parsed from the content, assuming
     * that the content was JSON. This is `undefined` if the
     * data could not be resolved, or it could not be parsed
     * to JSON.
     */
    private _parsedObject;
    /**
     * Whether the `_parsedObject` was already requested
     */
    private _parsedObjectWasRequested;
    /**
     * Creates a new instance of content data that is defined by
     * the given (usually relative) URI and the given buffer data
     *
     * @param uri - The URI of the content data
     * @param data - The actual content data buffer
     */
    constructor(uri: string, data: Buffer | null);
    /** {@inheritDoc ContentData.uri} */
    get uri(): string;
    /** {@inheritDoc ContentData.extension} */
    get extension(): string;
    /** {@inheritDoc ContentData.exists} */
    exists(): Promise<boolean>;
    /** {@inheritDoc ContentData.magic} */
    getMagic(): Promise<Buffer>;
    /** {@inheritDoc ContentData.data} */
    getData(): Promise<Buffer | null>;
    /** {@inheritDoc ContentData.getParsedObject} */
    getParsedObject(): Promise<any>;
}
//# sourceMappingURL=BufferedContentData.d.ts.map