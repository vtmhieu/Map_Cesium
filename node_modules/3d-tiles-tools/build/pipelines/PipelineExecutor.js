"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineExecutor = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const TilesetStageExecutor_1 = require("./TilesetStageExecutor");
/**
 * Methods to execute `Pipeline` objects.
 */
class PipelineExecutor {
    /**
     * Set the directory to store temporary files in.
     *
     * If this is `undefined`, then a directory in the
     * default system temp directory will be used.
     *
     * This is primarily intended for testing, demos, and
     * debugging.
     *
     * @param directory - The directory
     */
    static setTempBaseDirectory(directory) {
        PipelineExecutor.tempBaseDirectory = directory;
    }
    /**
     * Executes the given `Pipeline`.
     *
     * @param pipeline - The `Pipeline` object
     * @param overwrite - Whether outputs should be overwritten if
     * they already exist
     * @returns A promise that resolves when the process is finished
     * @throws PipelineError If one of the processing steps causes
     * an error.
     */
    static async executePipeline(pipeline, overwrite) {
        console.log("Executing pipeline");
        let currentInput = pipeline.input;
        let currentOutput = undefined;
        let currentOverwrite = true;
        const tilesetStages = pipeline.tilesetStages;
        // Create a temporary directory for the intermediate
        // processing steps (if there are more than one)
        // TODO: This is not cleaned up at the end...
        let tempBasePath = PipelineExecutor.tempBaseDirectory;
        if (!tempBasePath) {
            if (tilesetStages.length > 1) {
                tempBasePath = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), "3d-tiles-tools-pipeline-"));
            }
        }
        // Execute each `TilesetStage`
        for (let t = 0; t < tilesetStages.length; t++) {
            const tilesetStage = tilesetStages[t];
            const message = `  Executing tilesetStage ${t} of ` +
                `${tilesetStages.length}: ${tilesetStage.name}`;
            console.log(message);
            if (t == tilesetStages.length - 1) {
                currentOutput = pipeline.output;
                currentOverwrite = overwrite;
            }
            else {
                const nameSuffix = tilesetStage.name.replace(/[^\w\s]/gi, "");
                currentOutput = `${tempBasePath}/tilesetStage-${t}-${nameSuffix}`;
                currentOverwrite = true;
            }
            await TilesetStageExecutor_1.TilesetStageExecutor.executeTilesetStage(tilesetStage, currentInput, currentOutput, currentOverwrite);
            currentInput = currentOutput;
        }
    }
}
exports.PipelineExecutor = PipelineExecutor;
