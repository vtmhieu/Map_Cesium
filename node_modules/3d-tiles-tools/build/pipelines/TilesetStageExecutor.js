"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilesetStageExecutor = void 0;
const ContentStageExecutor_1 = require("./ContentStageExecutor");
const PipelineError_1 = require("./PipelineError");
const TilesetStages_1 = require("./TilesetStages");
const BasicTilesetProcessor_1 = require("../tilesetProcessing/BasicTilesetProcessor");
const TilesetUpgrader_1 = require("../tilesetProcessing/TilesetUpgrader");
const TilesetCombiner_1 = require("../tilesetProcessing/TilesetCombiner");
const ContentDataTypeChecks_1 = require("../contentTypes/ContentDataTypeChecks");
const ContentDataTypes_1 = require("../contentTypes/ContentDataTypes");
const TilesetDataProcessor_1 = require("../tilesetProcessing/TilesetDataProcessor");
const Buffers_1 = require("../base/Buffers");
/**
 * Methods to execute `TilesetStage` objects.
 */
class TilesetStageExecutor {
    /**
     * Executes the given `TilesetStage`.
     *
     * @param tilesetStage - The `TilesetStage` object
     * @param currentInput - The current input name, or a temporary
     * name for intermediate steps (see `Pipeline.input` for details)
     * @param currentOutput - The current output name, or a temporary
     * name for intermediate steps (see `Pipeline.input` for details)
     * @param overwrite - Whether outputs should be overwritten if
     * they already exist
     * @returns A promise that resolves when the process is finished
     * @throws PipelineError If one of the processing steps causes
     * an error.
     */
    static async executeTilesetStage(tilesetStage, currentInput, currentOutput, overwrite) {
        console.log(`  Executing tilesetStage : ${tilesetStage.name}`);
        console.log(`    currentInput:  ${currentInput}`);
        console.log(`    currentOutput: ${currentOutput}`);
        try {
            await TilesetStageExecutor.executeTilesetStageInternal(tilesetStage, currentInput, currentOutput, overwrite);
        }
        catch (e) {
            throw new PipelineError_1.PipelineError(`${e}`);
        }
    }
    /**
     * Implementation for `executeTilesetStage`.
     *
     * For details about the arguments, see `executeTilesetStage`.
     *
     * @param tilesetStage - The `TilesetStage` object
     * @param currentInput - The current input name
     * @param currentOutput - The current output name
     * @param overwrite - Whether outputs should be overwritten
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeTilesetStageInternal(tilesetStage, currentInput, currentOutput, overwrite) {
        if (tilesetStage.name === TilesetStages_1.TilesetStages.TILESET_STAGE_GZIP) {
            const condition = ContentDataTypeChecks_1.ContentDataTypeChecks.createTypeCheck(tilesetStage.includedContentTypes, tilesetStage.excludedContentTypes);
            await TilesetStageExecutor.executeGzip(currentInput, currentOutput, overwrite, condition);
        }
        else if (tilesetStage.name === TilesetStages_1.TilesetStages.TILESET_STAGE_UNGZIP) {
            await TilesetStageExecutor.executeGunzip(currentInput, currentOutput, overwrite);
        }
        else if (tilesetStage.name === TilesetStages_1.TilesetStages.TILESET_STAGE_UPGRADE) {
            const quiet = false;
            const gltfUpgradeOptions = undefined;
            const tilesetUpgrader = new TilesetUpgrader_1.TilesetUpgrader(quiet, gltfUpgradeOptions);
            await tilesetUpgrader.upgrade(currentInput, currentOutput, overwrite);
        }
        else if (tilesetStage.name === TilesetStages_1.TilesetStages.TILESET_STAGE_COMBINE) {
            const externalTilesetDetector = ContentDataTypeChecks_1.ContentDataTypeChecks.createIncludedCheck(ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_TILESET);
            const tilesetCombiner = new TilesetCombiner_1.TilesetCombiner(externalTilesetDetector);
            await tilesetCombiner.combine(currentInput, currentOutput, overwrite);
        }
        else {
            await TilesetStageExecutor.executeTilesetContentStages(tilesetStage, currentInput, currentOutput, overwrite);
        }
    }
    /**
     * Performs the 'gzip' tileset stage with the given parameters.
     *
     * This will process all entries of the source tileset. The
     * data of entries that match the given condition will be
     * compressed with gzip. Other entries remain unaffected.
     *
     * @param currentInput - The current input name
     * @param currentOutput - The current output name
     * @param overwrite - Whether outputs should be overwritten
     * @param condition The condition that was created from
     * the included- and excluded types that have been defined
     * in the `ContentStage`.
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeGzip(currentInput, currentOutput, overwrite, condition) {
        const quiet = true;
        const tilesetProcessor = new TilesetDataProcessor_1.TilesetDataProcessor(quiet);
        await tilesetProcessor.begin(currentInput, currentOutput, overwrite);
        // The entry processor receives the source entry, and
        // returns a target entry where the `value` is zipped
        // if the source entry matches the given condition.
        const entryProcessor = async (sourceEntry, type) => {
            let targetValue = sourceEntry.value;
            const shouldZip = condition(type);
            if (shouldZip) {
                targetValue = Buffers_1.Buffers.gzip(sourceEntry.value);
            }
            const targetEntry = {
                key: sourceEntry.key,
                value: targetValue,
            };
            return targetEntry;
        };
        await tilesetProcessor.processAllEntries(entryProcessor);
        await tilesetProcessor.end();
    }
    /**
     * Performs the 'gunzip' tileset stage with the given parameters.
     *
     * This will process all entries of the source tileset. The
     * data of entries that is compressed with gzip will be
     * uncompressed. Other entries remain unaffected.
     *
     * @param currentInput - The current input name
     * @param currentOutput - The current output name
     * @param overwrite - Whether outputs should be overwritten
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeGunzip(currentInput, currentOutput, overwrite) {
        const quiet = true;
        const tilesetProcessor = new TilesetDataProcessor_1.TilesetDataProcessor(quiet);
        await tilesetProcessor.begin(currentInput, currentOutput, overwrite);
        // The entry processor receives the source entry, and
        // returns a target entry where the `value` is unzipped
        // (If the data was not zipped, then `Buffers.gunzip`
        // returns an unmodified result)
        const entryProcessor = async (sourceEntry, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        type) => {
            const targetEntry = {
                key: sourceEntry.key,
                value: Buffers_1.Buffers.gunzip(sourceEntry.value),
            };
            return targetEntry;
        };
        await tilesetProcessor.processAllEntries(entryProcessor);
        await tilesetProcessor.end();
    }
    /**
     * Execute all `ContentStage` objects in the given `TilesetStage`.
     *
     * For details about the arguments, see `executeTilesetStage`.
     *
     * @param tilesetStage - The `TilesetStage` object
     * @param currentInput - The current input name
     * @param currentOutput - The current output name
     * @param overwrite - Whether outputs should be overwritten
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeTilesetContentStages(tilesetStage, currentInput, currentOutput, overwrite) {
        try {
            const quiet = false;
            const tilesetProcessor = new BasicTilesetProcessor_1.BasicTilesetProcessor(quiet);
            await tilesetProcessor.begin(currentInput, currentOutput, overwrite);
            const contentStages = tilesetStage.contentStages;
            if (contentStages) {
                for (let c = 0; c < contentStages.length; c++) {
                    const contentStage = contentStages[c];
                    const message = `    Executing contentStage ${c} of ` +
                        `${contentStages.length}: ${contentStage.name}`;
                    console.log(message);
                    await ContentStageExecutor_1.ContentStageExecutor.executeContentStage(contentStage, tilesetProcessor);
                }
                await tilesetProcessor.end();
            }
        }
        catch (e) {
            throw new PipelineError_1.PipelineError(`${e}`);
        }
    }
}
exports.TilesetStageExecutor = TilesetStageExecutor;
