"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentStageExecutor = void 0;
const path_1 = __importDefault(require("path"));
const gltf_pipeline_1 = __importDefault(require("gltf-pipeline"));
const Paths_1 = require("../base/Paths");
const ContentDataTypes_1 = require("../contentTypes/ContentDataTypes");
const ContentStages_1 = require("./ContentStages");
const PipelineError_1 = require("./PipelineError");
const GtlfUtilities_1 = require("../contentProcessing/GtlfUtilities");
const ContentOps_1 = require("../contentProcessing/ContentOps");
/**
 * Methods to execute `ContentStage` objects.
 */
class ContentStageExecutor {
    /**
     * Execute the given `ContentStage`.
     *
     * @param contentStage - The `ContentStage` object
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws PipelineError If one of the processing steps causes
     * an error.
     */
    static async executeContentStage(contentStage, tilesetProcessor) {
        try {
            await ContentStageExecutor.executeContentStageInternal(contentStage, tilesetProcessor);
        }
        catch (e) {
            throw new PipelineError_1.PipelineError(`${e}`);
        }
    }
    /**
     * Execute the given `ContentStage`.
     *
     * @param contentStage - The `ContentStage` object
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeContentStageInternal(contentStage, tilesetProcessor) {
        if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_GLB_TO_B3DM) {
            await ContentStageExecutor.executeGlbToB3dm(tilesetProcessor);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_GLB_TO_I3DM) {
            await ContentStageExecutor.executeGlbToI3dm(tilesetProcessor);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_B3DM_TO_GLB) {
            await ContentStageExecutor.executeB3dmToGlb(tilesetProcessor);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_I3DM_TO_GLB) {
            await ContentStageExecutor.executeI3dmToGlb(tilesetProcessor);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_OPTIMIZE_B3DM) {
            const options = contentStage.options;
            await ContentStageExecutor.executeOptimizeB3dm(tilesetProcessor, options);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_OPTIMIZE_I3DM) {
            const options = contentStage.options;
            await ContentStageExecutor.executeOptimizeI3dm(tilesetProcessor, options);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_OPTIMIZE_GLB) {
            const options = contentStage.options;
            await ContentStageExecutor.executeOptimizeGlb(tilesetProcessor, options);
        }
        else if (contentStage.name === ContentStages_1.ContentStages.CONTENT_STAGE_SEPARATE_GLTF) {
            await ContentStageExecutor.executeSeparateGltf(tilesetProcessor);
        }
        else {
            const message = `    Unknown contentStage name: ${contentStage.name}`;
            console.log(message);
        }
    }
    /**
     * Performs the 'glbToB3dm' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_GLB`. These entries will be replaced
     * by entries that contain the B3DM data that was created from the GLB.
     *
     * If the entries have names that end in `.glb`, then these
     * extensions will be changed to `.b3dm`.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeGlbToB3dm(tilesetProcessor) {
        // Define the rule for updating the key (file name) of
        // the entries, as well as possible template URIs of
        // implicit tileset roots.
        const uriProcessor = (uri) => {
            if (Paths_1.Paths.hasExtension(uri, ".glb")) {
                return Paths_1.Paths.replaceExtension(uri, ".b3dm");
            }
            return uri;
        };
        // Define the `TilesetEntryProcessor` that generates an
        // entry with B3DM data from an entry with GLB data.
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLB) {
                return sourceEntry;
            }
            const targetEntry = {
                key: uriProcessor(sourceEntry.key),
                value: ContentOps_1.ContentOps.glbToB3dmBuffer(sourceEntry.value),
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries(uriProcessor, entryProcessor);
    }
    /**
     * Performs the 'glbToI3dm' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_GLB`. These entries will be replaced
     * by entries that contain the I3DM data that was created from the GLB.
     *
     * If the entries have names that end in `.glb`, then these
     * extensions will be changed to `.i3dm`.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeGlbToI3dm(tilesetProcessor) {
        // Define the rule for updating the key (file name) of
        // the entries, as well as possible template URIs of
        // implicit tileset roots.
        const uriProcessor = (uri) => {
            if (Paths_1.Paths.hasExtension(uri, ".glb")) {
                return Paths_1.Paths.replaceExtension(uri, ".i3dm");
            }
            return uri;
        };
        // Define the `TilesetEntryProcessor` that generates an
        // entry with I3DM data from an entry with GLB data.
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLB) {
                return sourceEntry;
            }
            const targetEntry = {
                key: uriProcessor(sourceEntry.key),
                value: ContentOps_1.ContentOps.glbToI3dmBuffer(sourceEntry.value),
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries(uriProcessor, entryProcessor);
    }
    /**
     * Performs the 'b3dmToGlb' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_B3DM`. These entries will be replaced
     * by entries that contain the GLB data from the B3DM.
     *
     * If the entries have names that end in `.b3dm`, then these
     * extensions will be changed to `.glb`.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeB3dmToGlb(tilesetProcessor) {
        // Define the rule for updating the key (file name) of
        // the entries, as well as possible template URIs of
        // implicit tileset roots.
        const uriProcessor = (uri) => {
            if (Paths_1.Paths.hasExtension(uri, ".b3dm")) {
                return Paths_1.Paths.replaceExtension(uri, ".glb");
            }
            return uri;
        };
        // Define the `TilesetEntryProcessor` that generates an
        // entry with GLB data from an entry with B3DM data.
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_B3DM) {
                return sourceEntry;
            }
            const targetEntry = {
                key: uriProcessor(sourceEntry.key),
                value: ContentOps_1.ContentOps.b3dmToGlbBuffer(sourceEntry.value),
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries(uriProcessor, entryProcessor);
    }
    /**
     * Performs the 'i3dmToGlb' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_I3DM`. These entries will be replaced
     * by entries that contain the GLB data from the I3DM.
     *
     * If the entries have names that end in `.i3dm`, then these
     * extensions will be changed to `.glb`.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeI3dmToGlb(tilesetProcessor) {
        // Define the rule for updating the key (file name) of
        // the entries, as well as possible template URIs of
        // implicit tileset roots.
        const uriProcessor = (uri) => {
            if (Paths_1.Paths.hasExtension(uri, ".i3dm")) {
                return Paths_1.Paths.replaceExtension(uri, ".glb");
            }
            return uri;
        };
        // Define the `TilesetEntryProcessor` that generates an
        // entry with GLB data from an entry with I3DM data.
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_I3DM) {
                return sourceEntry;
            }
            const targetEntry = {
                key: uriProcessor(sourceEntry.key),
                value: ContentOps_1.ContentOps.i3dmToGlbBuffer(sourceEntry.value),
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries(uriProcessor, entryProcessor);
    }
    /**
     * Performs the 'optimizeB3dm' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_B3DM`, and apply the `gltf-pipeline`
     * optimization with the given options to their GLB data.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @param options - The options for `gltf-pipeline`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeOptimizeB3dm(tilesetProcessor, options) {
        // The entry processor receives the source entry, and
        // returns a target entry where the the `value` contains
        // GLB data that was optimized with `gltf-pipeline`
        // and the given options
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_B3DM) {
                return sourceEntry;
            }
            const targetValue = await ContentOps_1.ContentOps.optimizeB3dmBuffer(sourceEntry.value, options);
            const targetEntry = {
                key: sourceEntry.key,
                value: targetValue,
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries((uri) => uri, entryProcessor);
    }
    /**
     * Performs the 'optimizeI3dm' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_I3DM`, and apply the `gltf-pipeline`
     * optimization with the given options to their GLB data.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @param options - The options for `gltf-pipeline`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeOptimizeI3dm(tilesetProcessor, options) {
        // The entry processor receives the source entry, and
        // returns a target entry where the the `value` contains
        // GLB data that was optimized with `gltf-pipeline`
        // and the given options
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_I3DM) {
                return sourceEntry;
            }
            const targetValue = await ContentOps_1.ContentOps.optimizeI3dmBuffer(sourceEntry.value, options);
            const targetEntry = {
                key: sourceEntry.key,
                value: targetValue,
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries((uri) => uri, entryProcessor);
    }
    /**
     * Performs the 'optimizeGlb' content stage with the given processor.
     *
     * This will process all tile contents entries of the source tileset
     * that have the `CONTENT_TYPE_GLB`, and apply the `gltf-pipeline`
     * optimization with the given options to them.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @param options - The options for `gltf-pipeline`
     * @returns A promise that resolves when the process is finished
     * @throws Error If one of the processing steps causes
     * an error.
     */
    static async executeOptimizeGlb(tilesetProcessor, options) {
        // The entry processor receives the source entry, and
        // returns a target entry where the the `value` contains
        // GLB data that was optimized with `gltf-pipeline`
        // and the given options
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLB) {
                return sourceEntry;
            }
            const targetValue = await GtlfUtilities_1.GltfUtilities.optimizeGlb(sourceEntry.value, options);
            const targetEntry = {
                key: sourceEntry.key,
                value: targetValue,
            };
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries((uri) => uri, entryProcessor);
    }
    /**
     * Performs the 'separateGltf' content stage with the given processor.
     *
     * @param tilesetProcessor - The `BasicTilesetProcessor`
     * @returns A promise that resolves when the process is finished
     * @throws PipelineError If one of the processing steps causes
     * an error.
     */
    static async executeSeparateGltf(tilesetProcessor) {
        // Define the rule for updating the key (file name) of
        // the entries, as well as possible template URIs of
        // implicit tileset roots.
        const uriProcessor = (uri) => {
            if (Paths_1.Paths.hasExtension(uri, ".glb")) {
                return Paths_1.Paths.replaceExtension(uri, ".gltf");
            }
            return uri;
        };
        // The entry processor receives the source entry, and
        // returns a target entry where the the `value` contains
        // the glTF data that was generated with `gltf-pipeline`.
        // The additional external resources will be passed to
        // the tileset processor, to be stored in the target.
        const entryProcessor = async (sourceEntry, type) => {
            if (type !== ContentDataTypes_1.ContentDataTypes.CONTENT_TYPE_GLB) {
                return sourceEntry;
            }
            const dirname = path_1.default.dirname(sourceEntry.key);
            const prefix = Paths_1.Paths.replaceExtension(path_1.default.basename(sourceEntry.key), "");
            const options = {
                separate: true,
                name: prefix,
            };
            const gltfPipelineResults = await gltf_pipeline_1.default.glbToGltf(sourceEntry.value, options);
            const targetValue = Buffer.from(JSON.stringify(gltfPipelineResults.gltf));
            const targetEntry = {
                key: uriProcessor(sourceEntry.key),
                value: targetValue,
            };
            const separateResources = gltfPipelineResults.separateResources;
            const resourceKeys = Object.keys(separateResources);
            for (const resourceKey of resourceKeys) {
                const resourceValue = separateResources[resourceKey];
                const resourceTargetEntry = {
                    key: Paths_1.Paths.join(dirname, resourceKey),
                    value: resourceValue,
                };
                tilesetProcessor.storeTargetEntries(resourceTargetEntry);
                tilesetProcessor.markAsProcessed(resourceKey);
            }
            return targetEntry;
        };
        await tilesetProcessor.processTileContentEntries(uriProcessor, entryProcessor);
    }
}
exports.ContentStageExecutor = ContentStageExecutor;
