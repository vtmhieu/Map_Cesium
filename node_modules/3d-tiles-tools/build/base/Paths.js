"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Paths = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Utility methods related to paths.
 *
 * The methods in this class are mainly convenience wrappers
 * around certain `fs`- and `path` functions.
 *
 * Unless otherwise noted, methods that return string
 * representations of paths will use the forward slash `/`
 * as the directory separator, regardless of the operating
 * system.
 *
 * @internal
 */
class Paths {
    /**
     * Ensures that the given directory exists, creating it
     * and all its parent directories if necessary.
     *
     * @param directory - The directory
     */
    static ensureDirectoryExists(directory) {
        if (!fs_1.default.existsSync(directory)) {
            fs_1.default.mkdirSync(directory, { recursive: true });
        }
    }
    /**
     * Returns whether the given path is a directory
     *
     * @param p - The path
     * @returns Whether the path is a directory
     */
    static isDirectory(p) {
        return fs_1.default.lstatSync(p).isDirectory();
    }
    /**
     * Returns whether the given file name has one of the given
     * extensions, case-insensitively.
     *
     * @param fileName - The file name
     * @param extensions - The extensions to check, in lowercase,
     * and including the `.` dot.
     * @returns Whether the file name has one of the given extensions.
     */
    static hasExtension(fileName, ...extensions) {
        const extension = path_1.default.extname(fileName).toLowerCase();
        return extensions.includes(extension);
    }
    /**
     * Replace the extension in the given file name with the new one.
     *
     * If the given file name does not have an extension, then the
     * given extension is appended.
     *
     * @param fileName - The file name
     * @param newExtension - The new extension (including the `.` dot)
     * @returns The new name
     */
    static replaceExtension(fileName, newExtension) {
        const extension = path_1.default.extname(fileName);
        const baseName = fileName.substring(0, fileName.length - extension.length);
        const newName = baseName + newExtension;
        return Paths.normalize(newName);
    }
    /**
     * Does whatever `path.join` does, but makes sure that
     * the result uses `/` forward slashes as the directory
     * separator.
     *
     * @param paths - The input paths
     * @returns The resulting joined path
     */
    static join(...paths) {
        const joined = path_1.default.join(...paths);
        return Paths.normalize(joined);
    }
    /**
     * Does whatever `path.resolve` does, but makes sure that
     * the result uses `/` forward slashes as the directory
     * separator.
     *
     * @param paths - The input paths
     * @returns The resulting resolved path
     */
    static resolve(...paths) {
        const resolved = path_1.default.resolve(...paths);
        return Paths.normalize(resolved);
    }
    /**
     * Does whatever `path.relative` does, but makes sure that
     * the result uses `/` forward slashes as the directory
     * separator.
     *
     * @param directory - The directory
     * @param fileName - The file name
     * @returns The resulting path
     */
    static relativize(directory, fileName) {
        const relative = path_1.default.relative(directory, fileName);
        return Paths.normalize(relative);
    }
    /**
     * Internal method to replace `\` backslashes with `/` forward slashes.
     *
     * @param p - The input path
     * @returns The result
     */
    static normalize(p) {
        return p.replace(/\\/g, "/");
    }
}
exports.Paths = Paths;
