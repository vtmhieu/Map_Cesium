/// <reference types="node" />
/**
 * Methods related to buffers.
 *
 * The methods in this class are convenience methods that
 * are mainly used for handling buffers that contain tile
 * data.
 *
 * @internal
 */
export declare class Buffers {
    /**
     * Applies GZIP compression to the given buffer, and returns
     * the result.
     *
     * @param inputBuffer - The input buffer
     * @returns The resulting buffer
     */
    static gzip(inputBuffer: Buffer): Buffer;
    /**
     * If the given buffer is compressed with GZIP, then it is
     * unzipped, and the result is returned. Otherwise, the
     * given buffer is returned as it is.
     *
     * @param inputBuffer - The input buffer
     * @returns The resulting buffer
     * @throws DataError If the buffer looked like GZIPped
     * data, but could not be decompressed.
     */
    static gunzip(inputBuffer: Buffer): Buffer;
    /**
     * Obtains the magic header bytes from the given buffer.
     *
     * This returns up to `byteLength` bytes of the given buffer,
     * starting at the given byte offset. If the buffer length
     * is too small, then a shorter buffer may be returned.
     *
     * @param buffer - The buffer
     * @param byteOffset - The byte offset, usually 0
     * @param byteLength - The byte length
     * @returns The magic header.
     */
    static getMagicBytes(buffer: Buffer, byteOffset: number, byteLength: number): Buffer;
    /**
     * Obtains the magic header from the given buffer, interpreted
     * as an ASCII string
     *
     * This returns up to 4 bytes of the given buffer, starting at
     * the given byte offset, converted to an ASCII string. If the
     * buffer length is too small, then a shorter string may be
     * returned.
     *
     * @param buffer - The buffer
     * @param byteOffset - The optional byte offset, defaulting to 0
     * @returns The magic header.
     */
    static getMagicString(buffer: Buffer, byteOffset?: number): string;
    /**
     * Returns whether the first bytes of the given buffer indicate
     * that it contains data that was compressed with GZIP
     *
     * @param buffer - The buffer
     * @returns Whether the buffer contains GZIPed data
     */
    static isGzipped(buffer: Buffer): boolean;
    /**
     * Returns whether the data in the given buffer is probably JSON.
     *
     * This does a best-effort approach of detecting whether the data
     * is very likely to be JSON data. The details are unspecified,
     * but it may, for example, check whether the first non-whitespace
     * character in the buffer is a `[` or `{`.
     *
     * @param buffer - The buffer
     * @returns Whether the buffer data is probably JSON data
     */
    static isProbablyJson(buffer: Buffer): boolean;
    /**
     * Parses JSON data from the given buffer.
     *
     * If the given buffer is empty, then an empty object will
     * be returned.
     *
     * @param buffer - The buffer
     * @returns The parsed object
     * @throws DataError If the JSON could not be parsed
     */
    static getJson(buffer: Buffer): any;
    /**
     * Creates a buffer that contains the JSON representation
     * of the given object, padding the end of the data with
     * spaces if necessary to make sure that the data ends
     * at an 8-byte boundary.
     *
     * @param json - The object
     * @param byteOffset - An optional offset where the buffer
     * is assumed to start, defaulting to 0
     * @returns The buffer
     */
    static getJsonBufferPadded(json: any, byteOffset?: number): Buffer;
    /**
     * Ensures that the given buffer ends at an 8-byte boundary,
     * padding it with zero-bytes at the end if necessary.
     *
     * If the buffer already ends at an 8-byte boundary, it is
     * returned directly. Otherwise, a new, padded buffer is
     * returned.
     *
     * @param json - The object
     * @param byteOffset - An optional offset where the buffer
     * is assumed to start, defaulting to 0
     * @returns The buffer
     */
    static getBufferPadded(buffer: Buffer, byteOffset?: number): Buffer;
    /**
     * Returns a short string that describes the Unicode BOM (Byte Order Mask)
     * that the given buffer starts with, or `undefined` if the buffer does
     * not contain a BOM
     *
     * @param buffer - The buffer
     * @returns A short description of the BOM, or `undefined`
     * @internal
     */
    static getUnicodeBOMDescription(buffer: Buffer): string | undefined;
    /**
     * Returns whether the given buffer starts with the given sequence
     * of bytes.
     *
     * @param buffer - The buffer
     * @param bytes - The bytes
     * @returns Whether the buffer starts with the given bytes
     * @internal
     */
    private static startsWith;
    /**
     * Creates a string representation of the given buffer where each
     * byte is encoded in its binary form, consisting of 8 bits.
     *
     * Warning: This is primarily intended for debugging. The resulting
     * string may be very long...
     *
     * @param buffer - The input buffer
     * @returns The resulting string
     */
    static createBinaryString(buffer: Buffer): string;
}
//# sourceMappingURL=Buffers.d.ts.map