"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Iterables = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Utility methods for iterable objects.
 *
 * @internal
 */
class Iterables {
    /**
     * Creates a generator that allows iterating over all files
     * in the given directory, and its subdirectories if
     * `recurse` is `true`.
     *
     * @param directory - The directory
     * @param recurse - Whether the files should
     * be listed recursively
     * @returns The generator for path strings
     */
    static *overFiles(directory, recurse) {
        const fileNames = fs_1.default.readdirSync(directory);
        for (const fileName of fileNames) {
            const rawPath = path_1.default.join(directory.toString(), fileName);
            const fullPath = rawPath.replace(/\\/g, "/");
            const isDirectory = fs_1.default.statSync(fullPath).isDirectory();
            if (isDirectory && recurse) {
                yield* Iterables.overFiles(fullPath, recurse);
            }
            else if (!isDirectory) {
                yield fullPath;
            }
        }
    }
    /**
     * Returns filtered view on the given iterable
     *
     * @param iterable - The iterable
     * @param include - The include predicate
     * @returns The filtered iterable
     */
    static filter(iterable, include) {
        const iterator = iterable[Symbol.iterator]();
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                for (;;) {
                    const result = iterator.next();
                    if (result.done) {
                        return { value: undefined, done: true };
                    }
                    const included = include(result.value);
                    if (included) {
                        return { value: result.value, done: false };
                    }
                }
            },
        };
    }
    /**
     * Creates an iterable from the given one, applying the
     * given function to each element.
     *
     * @param iterable - The iterable object
     * @param mapper - The mapper function
     * @returns The mapped iterable
     */
    static map(iterable, mapper) {
        const iterator = iterable[Symbol.iterator]();
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                const result = iterator.next();
                if (result.done) {
                    return { value: undefined, done: true };
                }
                const mappedValue = mapper(result.value);
                return { value: mappedValue, done: false };
            },
        };
    }
}
exports.Iterables = Iterables;
