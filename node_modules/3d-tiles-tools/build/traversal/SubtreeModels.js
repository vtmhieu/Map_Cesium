"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubtreeModels = void 0;
const path_1 = __importDefault(require("path"));
const defined_1 = require("../base/defined");
const Buffers_1 = require("../base/Buffers");
const BinarySubtreeDataResolver_1 = require("../implicitTiling/BinarySubtreeDataResolver");
const ImplicitTilingError_1 = require("../implicitTiling/ImplicitTilingError");
const ImplicitTilings_1 = require("../implicitTiling/ImplicitTilings");
const SubtreeInfos_1 = require("../implicitTiling/SubtreeInfos");
const SubtreeMetadataModels_1 = require("./SubtreeMetadataModels");
/**
 * Methods to resolve subtree information.
 *
 * The methods will resolve the data for a subtree, based on the template
 * URI from the implicit tiling and the root coordinates of the subtree,
 * and offer this information as `SubtreeModel` objects.
 *
 * @internal
 */
class SubtreeModels {
    /**
     * Resolve the `SubtreeModel` for the subtree with the given root coordinates.
     *
     * This will substitute the given coordinates into the subtree template
     * URI from the given implicit tiling object. Then it will attempt to load
     * the subtree data from this URI. The resulting data will be used to
     * construct the `SubtreeModel` object.
     *
     * @param implicitTiling - The `TileImplicitTiling`
     * @param schema - The optional metadata schema
     * @param resourceResolver - The `ResourceResolver` for the subtree
     * files and buffers
     * @param coordinates - The root coordinates of the subtree
     * @returns The `SubtreeModel`
     * @throws ImplicitTilingError If the input was structurally invalid
     */
    static async resolve(implicitTiling, schema, resourceResolver, coordinates) {
        // Obtain the raw subtree data by resolving the data from
        // the URI that is created from the template URI and the
        // coordinates
        const subtreeUri = ImplicitTilings_1.ImplicitTilings.substituteTemplateUri(implicitTiling.subdivisionScheme, implicitTiling.subtrees.uri, coordinates);
        if (!(0, defined_1.defined)(subtreeUri)) {
            const message = `Could not substitute coordinates ${coordinates} in ` +
                `subtree template URI ${implicitTiling.subtrees.uri}`;
            throw new ImplicitTilingError_1.ImplicitTilingError(message);
        }
        const subtreeData = await resourceResolver.resolveData(subtreeUri);
        if (!subtreeData) {
            const message = `Could not resolve subtree URI ${subtreeUri} that was ` +
                `created from template URI ${implicitTiling.subtrees.uri} ` +
                `for coordinates ${coordinates}`;
            throw new ImplicitTilingError_1.ImplicitTilingError(message);
        }
        // Create the resource resolver that will be used
        // for resolving references (buffer URIs) relative
        // to the directory that contained the subtree data
        const subtreeDirectory = path_1.default.dirname(subtreeUri);
        const subtreeResourceResolver = resourceResolver.derive(subtreeDirectory);
        // If the subtree data was JSON, just parse it and
        // create a SubtreeModel from it
        const isJson = Buffers_1.Buffers.isProbablyJson(subtreeData);
        if (isJson) {
            let subtreeJson;
            let subtree;
            try {
                subtreeJson = Buffers_1.Buffers.getJson(subtreeData);
                subtree = subtreeJson;
            }
            catch (error) {
                const message = `Could not parse subtree JSON from URI ${subtreeUri} that was ` +
                    `created from template URI ${implicitTiling.subtrees.uri} ` +
                    `for coordinates ${coordinates}`;
                throw new ImplicitTilingError_1.ImplicitTilingError(message);
            }
            const binarySubtreeData = await BinarySubtreeDataResolver_1.BinarySubtreeDataResolver.resolveFromJson(subtree, subtreeResourceResolver);
            const subtreeModel = SubtreeModels.create(binarySubtreeData, implicitTiling, schema);
            return subtreeModel;
        }
        // For SUBT (binary subtree data), create the SubtreeModel
        // from the whole buffer
        const isSubt = Buffers_1.Buffers.getMagicString(subtreeData) === "subt";
        if (isSubt) {
            const binarySubtreeData = await BinarySubtreeDataResolver_1.BinarySubtreeDataResolver.resolveFromBuffer(subtreeData, subtreeResourceResolver);
            const subtreeModel = SubtreeModels.create(binarySubtreeData, implicitTiling, schema);
            return subtreeModel;
        }
        const message = `Subtree data from URI ${subtreeUri} that was created from ` +
            `template URI ${implicitTiling.subtrees.uri} for coordinates ` +
            `${coordinates} did neither contain JSON nor binary subtree data`;
        throw new ImplicitTilingError_1.ImplicitTilingError(message);
    }
    /**
     * Creates the `SubtreeModel` from the given binary subtree data
     *
     * @param binarySubtreeData - The binary subtree data
     * @param implicitTiling - The `TileImplicitTiling`
     * @param schema - The optional metadata schema
     * @returns The `SubtreeModel`
     * @throws ImplicitTilingError If the input was structurally invalid
     */
    static create(binarySubtreeData, implicitTiling, schema) {
        const subtreeInfo = SubtreeInfos_1.SubtreeInfos.create(binarySubtreeData, implicitTiling);
        let subtreeMetadataModel = undefined;
        if (schema) {
            subtreeMetadataModel = SubtreeMetadataModels_1.SubtreeMetadataModels.create(binarySubtreeData, subtreeInfo, schema);
        }
        const subtreeModel = {
            subtreeInfo: subtreeInfo,
            subtreeMetadataModel: subtreeMetadataModel,
        };
        return subtreeModel;
    }
}
exports.SubtreeModels = SubtreeModels;
