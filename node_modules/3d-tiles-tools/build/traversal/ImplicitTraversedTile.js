"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImplicitTraversedTile = void 0;
const defined_1 = require("../base/defined");
const SubtreeModels_1 = require("./SubtreeModels");
const ImplicitTilingError_1 = require("../implicitTiling/ImplicitTilingError");
const ImplicitTilings_1 = require("../implicitTiling/ImplicitTilings");
const BoundingVolumeDerivation_1 = require("./cesium/BoundingVolumeDerivation");
const MetadataSemanticOverrides_1 = require("./MetadataSemanticOverrides");
/**
 * An implementation of a `TraversedTile` that represents a tile
 * within an implicit tileset during its traversal.
 *
 * @internal
 */
class ImplicitTraversedTile {
    constructor(implicitTiling, resourceResolver, root, path, subtreeModel, globalLevel, globalCoordinate, rootCoordinate, localCoordinate, parent) {
        // TODO For debugging
        this.toString = () => {
            return (`ImplicitTraversedTile, ` +
                `level ${this._globalLevel}, ` +
                `global: ${this._globalCoordinate}, ` +
                `root: ${this._rootCoordinate}, ` +
                `local: ${this._localCoordinate}`
            //`path ${this.path}`
            );
        };
        this._implicitTiling = implicitTiling;
        this._resourceResolver = resourceResolver;
        this._root = root;
        this._path = path;
        this._subtreeModel = subtreeModel;
        this._globalLevel = globalLevel;
        this._globalCoordinate = globalCoordinate;
        this._rootCoordinate = rootCoordinate;
        this._localCoordinate = localCoordinate;
        this._parent = parent;
    }
    /** {@inheritDoc TraversedTile.asRawTile} */
    asRawTile() {
        const rootTile = this._root.asFinalTile();
        const boundingVolume = BoundingVolumeDerivation_1.BoundingVolumeDerivation.deriveBoundingVolume(rootTile.boundingVolume, this._globalCoordinate.toArray());
        if (!boundingVolume) {
            // The bounding volume was not a region, box, or S2 Cell.
            throw new ImplicitTilingError_1.ImplicitTilingError("Could not subdivide bounding volume");
        }
        const level = this._globalCoordinate.level;
        const geometricError = rootTile.geometricError / Math.pow(2, level);
        const viewerRequestVolume = rootTile.viewerRequestVolume;
        const refine = rootTile.refine;
        const transform = undefined;
        const metadata = undefined;
        const contents = this.getRawContents();
        const implicitTiling = undefined;
        const extensions = undefined;
        const extras = undefined;
        return {
            boundingVolume: boundingVolume,
            viewerRequestVolume: viewerRequestVolume,
            geometricError: geometricError,
            refine: refine,
            transform: transform,
            metadata: metadata,
            contents: contents,
            implicitTiling: implicitTiling,
            extensions: extensions,
            extras: extras,
        };
    }
    /** {@inheritDoc TraversedTile.asFinalTile} */
    asFinalTile() {
        const tile = this.asRawTile();
        tile.contents = this.getFinalContents();
        const subtreeMetadataModel = this._subtreeModel.subtreeMetadataModel;
        if (subtreeMetadataModel) {
            const tileIndex = this._localCoordinate.toIndex();
            MetadataSemanticOverrides_1.MetadataSemanticOverrides.applyImplicitTileMetadataSemanticOverrides(tile, tileIndex, subtreeMetadataModel);
        }
        return tile;
    }
    /** {@inheritDoc TraversedTile.path} */
    get path() {
        return this._path;
    }
    /** {@inheritDoc TraversedTile.level} */
    get level() {
        return this._globalLevel;
    }
    /**
     * Returns the local coordinate of this implicit tile.
     *
     * This is the coordinate referring to the nearest subtree root.
     *
     * @returns The local coordinate
     */
    getLocalCoordinate() {
        return this._localCoordinate;
    }
    /**
     * Returns the global coordinate of this implicit tile.
     *
     * This is the coordinate referring to the root of the
     * implicit tile hierarchy.
     *
     * @returns The global coordinate
     */
    getGlobalCoordinate() {
        return this._globalCoordinate;
    }
    /** {@inheritDoc TraversedTile.getParent} */
    getParent() {
        return this._parent;
    }
    /** {@inheritDoc TraversedTile.getChildren} */
    async getChildren() {
        const localLevel = this._localCoordinate.level;
        if (localLevel === this._implicitTiling.subtreeLevels - 1) {
            const children = await this.createNextSubtreeLevelChildren();
            return children;
        }
        const children = await this.createDirectChildren();
        return children;
    }
    /**
     * Creates the children for this tile at which a new subtree starts.
     *
     * This assumes that this tile is in the last level of the subtree
     * that it belongs to. This method will create one child tile for
     * each available child subtree. These children will be the "local
     * roots" of their respective subtree.
     *
     * @returns The children
     * @throws ImplicitTilingError If the input data was invalid
     */
    async createNextSubtreeLevelChildren() {
        const subtreeInfo = this._subtreeModel.subtreeInfo;
        const traversedChildren = [];
        const localChildCoordinates = this._localCoordinate.children();
        for (const localChildCoordinate of localChildCoordinates) {
            const globalChildCoordinate = ImplicitTilings_1.ImplicitTilings.globalizeCoordinates(this._implicitTiling, this._rootCoordinate, localChildCoordinate);
            const childSubtreeAvailability = subtreeInfo.childSubtreeAvailabilityInfo;
            const childSubtreeAvailable = childSubtreeAvailability.isAvailable(localChildCoordinate.toIndexInLevel());
            if (childSubtreeAvailable) {
                const schema = this._subtreeModel.subtreeMetadataModel?.schema;
                const childSubtreeModel = await SubtreeModels_1.SubtreeModels.resolve(this._implicitTiling, schema, this._resourceResolver, globalChildCoordinate);
                const childLocalCoordinate = ImplicitTilings_1.ImplicitTilings.createRootCoordinates(this._implicitTiling);
                // The path is composed from the path of the root and the string
                // representation of the global coordinates of the child
                const coordinateString = ImplicitTilings_1.ImplicitTilings.createString(globalChildCoordinate);
                const childPath = `${this._root.path}/${coordinateString}`;
                const traversedChild = new ImplicitTraversedTile(this._implicitTiling, this._resourceResolver, this._root, childPath, childSubtreeModel, this._globalLevel + 1, globalChildCoordinate, globalChildCoordinate, childLocalCoordinate, this);
                traversedChildren.push(traversedChild);
            }
        }
        return traversedChildren;
    }
    /**
     * Creates the children for this tile that are still within the same subtree.
     *
     * This assumes that this tile is **NOT** in the last level of the subtree.
     * It will return all children that are marked as available, via the
     * tile availability information in the subtree that this tile belongs to.
     *
     * @returns The children
     * @throws ImplicitTilingError If the input data was invalid
     */
    async createDirectChildren() {
        const subtreeInfo = this._subtreeModel.subtreeInfo;
        const tileAvailabilityInfo = subtreeInfo.tileAvailabilityInfo;
        const localChildCoordinates = this._localCoordinate.children();
        const traversedChildren = [];
        for (const localChildCoordinate of localChildCoordinates) {
            const available = tileAvailabilityInfo.isAvailable(localChildCoordinate.toIndex());
            if (available) {
                const globalChildCoordinate = ImplicitTilings_1.ImplicitTilings.globalizeCoordinates(this._implicitTiling, this._rootCoordinate, localChildCoordinate);
                // The path is composed from the path of the root and the string
                // representation of the global coordinates of the child
                const coordinateString = ImplicitTilings_1.ImplicitTilings.createString(globalChildCoordinate);
                const childPath = `${this._root.path}/${coordinateString}`;
                const traversedChild = new ImplicitTraversedTile(this._implicitTiling, this._resourceResolver, this._root, childPath, this._subtreeModel, this._globalLevel + 1, globalChildCoordinate, this._rootCoordinate, localChildCoordinate, this);
                traversedChildren.push(traversedChild);
            }
        }
        return traversedChildren;
    }
    /** {@inheritDoc TraversedTile.getRawContents} */
    getRawContents() {
        const contents = [];
        const subtreeInfo = this._subtreeModel.subtreeInfo;
        const contentAvailabilityInfos = subtreeInfo.contentAvailabilityInfos;
        const tileIndex = this._localCoordinate.toIndex();
        for (const contentAvailabilityInfo of contentAvailabilityInfos) {
            const available = contentAvailabilityInfo.isAvailable(tileIndex);
            if (available) {
                // TODO The existence of the root content URI should
                // have been validated. So this could also throw
                // an error if the template URI is not found.
                const templateUri = this._root.asRawTile().content?.uri;
                if ((0, defined_1.defined)(templateUri)) {
                    const contentUri = ImplicitTilings_1.ImplicitTilings.substituteTemplateUri(this._implicitTiling.subdivisionScheme, templateUri, this._globalCoordinate);
                    const content = {
                        boundingVolume: undefined,
                        uri: contentUri,
                        metadata: undefined,
                        group: undefined,
                    };
                    contents.push(content);
                }
            }
        }
        return contents;
    }
    /** {@inheritDoc TraversedTile.getFinalContents} */
    getFinalContents() {
        const contents = this.getRawContents();
        const subtreeMetadataModel = this._subtreeModel.subtreeMetadataModel;
        if (!subtreeMetadataModel) {
            return contents;
        }
        const tileIndex = this._localCoordinate.toIndex();
        for (let i = 0; i < contents.length; i++) {
            const content = contents[i];
            MetadataSemanticOverrides_1.MetadataSemanticOverrides.applyImplicitContentMetadataSemanticOverrides(content, i, tileIndex, subtreeMetadataModel);
        }
        return contents;
    }
    /** {@inheritDoc TraversedTile.getResourceResolver} */
    getResourceResolver() {
        return this._resourceResolver;
    }
    /** {@inheritDoc TraversedTile.isImplicitTilesetRoot} */
    isImplicitTilesetRoot() {
        return false;
    }
    /** {@inheritDoc TraversedTile.getSubtreeUri} */
    getSubtreeUri() {
        const localCoordinate = this._localCoordinate;
        if (localCoordinate.level === 0) {
            const globalCoordinate = this._globalCoordinate;
            const implicitTiling = this._implicitTiling;
            const subtreeUri = ImplicitTilings_1.ImplicitTilings.substituteTemplateUri(implicitTiling.subdivisionScheme, implicitTiling.subtrees.uri, globalCoordinate);
            return subtreeUri;
        }
        return undefined;
    }
}
exports.ImplicitTraversedTile = ImplicitTraversedTile;
