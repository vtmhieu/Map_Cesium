import { ResourceResolver } from "../io/ResourceResolver";
import { TraversedTile } from "./TraversedTile";
import { SubtreeModel } from "./SubtreeModel";
import { Tile } from "../structure/Tile";
import { Content } from "../structure/Content";
import { TileImplicitTiling } from "../structure/TileImplicitTiling";
import { TreeCoordinates } from "../spatial/TreeCoordinates";
/**
 * An implementation of a `TraversedTile` that represents a tile
 * within an implicit tileset during its traversal.
 *
 * @internal
 */
export declare class ImplicitTraversedTile implements TraversedTile {
    /**
     * The `TileImplicitTiling` that this tile belongs to
     */
    private readonly _implicitTiling;
    /**
     * The `ResourceResolver` that will be used for loading
     * subtree files.
     */
    private readonly _resourceResolver;
    /**
     * The tile that corresponds to the root tile from the
     * tileset JSON (i.e. the one that contained the
     * `TileImplicitTiling` object)
     */
    private readonly _root;
    /**
     * A JSON-path like path identifying this tile
     */
    private readonly _path;
    /**
     * The `SubtreeModel` object that will be used for accessing
     * the availability information and metadata for the subtree
     * that this tile belongs to.
     */
    private readonly _subtreeModel;
    /**
     * The global level of this tile. This refers to the
     * root of the tileset.
     */
    private readonly _globalLevel;
    /**
     * The global coordinate of this tile within the implicit tileset.
     */
    private readonly _globalCoordinate;
    /**
     * The root coordinate of the subtree that this tile belongs
     * to, within the whole implicit tileset.
     */
    private readonly _rootCoordinate;
    /**
     * The local coordinate of this tile within the subtree that
     * starts at the `_rootCoordinate`
     */
    private readonly _localCoordinate;
    /**
     * The parent tile
     */
    private readonly _parent;
    constructor(implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver, root: TraversedTile, path: string, subtreeModel: SubtreeModel, globalLevel: number, globalCoordinate: TreeCoordinates, rootCoordinate: TreeCoordinates, localCoordinate: TreeCoordinates, parent: TraversedTile);
    /** {@inheritDoc TraversedTile.asRawTile} */
    asRawTile(): Tile;
    /** {@inheritDoc TraversedTile.asFinalTile} */
    asFinalTile(): Tile;
    /** {@inheritDoc TraversedTile.path} */
    get path(): string;
    /** {@inheritDoc TraversedTile.level} */
    get level(): number;
    /**
     * Returns the local coordinate of this implicit tile.
     *
     * This is the coordinate referring to the nearest subtree root.
     *
     * @returns The local coordinate
     */
    getLocalCoordinate(): TreeCoordinates;
    /**
     * Returns the global coordinate of this implicit tile.
     *
     * This is the coordinate referring to the root of the
     * implicit tile hierarchy.
     *
     * @returns The global coordinate
     */
    getGlobalCoordinate(): TreeCoordinates;
    /** {@inheritDoc TraversedTile.getParent} */
    getParent(): TraversedTile | undefined;
    /** {@inheritDoc TraversedTile.getChildren} */
    getChildren(): Promise<TraversedTile[]>;
    /**
     * Creates the children for this tile at which a new subtree starts.
     *
     * This assumes that this tile is in the last level of the subtree
     * that it belongs to. This method will create one child tile for
     * each available child subtree. These children will be the "local
     * roots" of their respective subtree.
     *
     * @returns The children
     * @throws ImplicitTilingError If the input data was invalid
     */
    private createNextSubtreeLevelChildren;
    /**
     * Creates the children for this tile that are still within the same subtree.
     *
     * This assumes that this tile is **NOT** in the last level of the subtree.
     * It will return all children that are marked as available, via the
     * tile availability information in the subtree that this tile belongs to.
     *
     * @returns The children
     * @throws ImplicitTilingError If the input data was invalid
     */
    private createDirectChildren;
    /** {@inheritDoc TraversedTile.getRawContents} */
    getRawContents(): Content[];
    /** {@inheritDoc TraversedTile.getFinalContents} */
    getFinalContents(): Content[];
    /** {@inheritDoc TraversedTile.getResourceResolver} */
    getResourceResolver(): ResourceResolver;
    /** {@inheritDoc TraversedTile.isImplicitTilesetRoot} */
    isImplicitTilesetRoot(): boolean;
    /** {@inheritDoc TraversedTile.getSubtreeUri} */
    getSubtreeUri(): string | undefined;
    toString: () => string;
}
//# sourceMappingURL=ImplicitTraversedTile.d.ts.map