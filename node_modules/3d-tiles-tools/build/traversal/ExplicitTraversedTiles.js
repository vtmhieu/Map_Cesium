"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExplicitTraversedTiles = void 0;
const ImplicitTraversedTile_1 = require("./ImplicitTraversedTile");
const SubtreeModels_1 = require("./SubtreeModels");
const ImplicitTilingError_1 = require("../implicitTiling/ImplicitTilingError");
const ImplicitTilings_1 = require("../implicitTiling/ImplicitTilings");
/**
 * Internal methods used in the `ExplicitTraversedTile` class.
 *
 * (Specifically: Methods to create the children of explicit
 * tiles, when these explicit tiles define the root of an
 * implicit tileset)
 *
 * @internal
 */
class ExplicitTraversedTiles {
    /**
     * Create the traversed children for the given explicit traversed tile.
     *
     * This method will be called from `ExplicitTraversedTile` instances
     * when the contain `implicitTiling` information, in order to create
     * the traversed children.
     *
     * The children will then be a single-element array that contains the
     * root node of the implicit tileset, as an `ImplicitTraversedTile`.
     *
     * @param implicitTiling - The `TileImplicitTiling`
     * @param parent - The `ExplicitTraversedTile`
     * @param schema - The optional metadata schema
     * @param resourceResolver - The `ResourceResolver` that
     * will be used e.g. for subtree files
     * @returns The traversed children
     * @throws ImplicitTilingError If the input was structurally invalid
     */
    static async createTraversedChildren(implicitTiling, schema, parent, resourceResolver) {
        const subdivisionScheme = implicitTiling.subdivisionScheme;
        if (subdivisionScheme === "QUADTREE") {
            const child = await ExplicitTraversedTiles.createImplicitQuadtreeRoot(implicitTiling, schema, parent, resourceResolver);
            return [child];
        }
        if (subdivisionScheme === "OCTREE") {
            const child = await ExplicitTraversedTiles.createImplicitOctreeRoot(implicitTiling, schema, parent, resourceResolver);
            return [child];
        }
        throw new ImplicitTilingError_1.ImplicitTilingError("Invalid subdivisionScheme: " + subdivisionScheme);
    }
    /**
     * Creates the root node for the traversal of an implicit quadtree.
     *
     * @param implicitTiling - The `TileImplicitTiling`
     * @param schema - The optional metadata schema
     * @param parent - The `ExplicitTraversedTile`
     * @param resourceResolver - The `ResourceResolver` that
     * will be used e.g. for subtree files
     * @returns The root of an implicit quadtree
     * @throws ImplicitTilingError If the input was structurally invalid
     */
    static async createImplicitQuadtreeRoot(implicitTiling, schema, parent, resourceResolver) {
        const rootCoordinates = ImplicitTilings_1.ImplicitTilings.createRootCoordinates(implicitTiling);
        const subtreeModel = await SubtreeModels_1.SubtreeModels.resolve(implicitTiling, schema, resourceResolver, rootCoordinates);
        // The path is composed from the path of the parent and the string
        // representation of the root coordinates
        const coordinateString = ImplicitTilings_1.ImplicitTilings.createString(rootCoordinates);
        const path = `${parent.path}/${coordinateString}`;
        const root = new ImplicitTraversedTile_1.ImplicitTraversedTile(implicitTiling, resourceResolver, parent, path, subtreeModel, parent.level + 1, rootCoordinates, rootCoordinates, rootCoordinates, parent);
        return root;
    }
    /**
     * Creates the root node for the traversal of an implicit octree.
     *
     * @param implicitTiling - The `TileImplicitTiling`
     * @param schema - The optional metadata schema
     * @param parent - The `ExplicitTraversedTile`
     * @param resourceResolver - The `ResourceResolver` that
     * will be used e.g. for subtree files
     * @returns The root of an implicit octree
     * @throws ImplicitTilingError If the input was structurally invalid
     */
    static async createImplicitOctreeRoot(implicitTiling, schema, parent, resourceResolver) {
        const rootCoordinates = ImplicitTilings_1.ImplicitTilings.createRootCoordinates(implicitTiling);
        const subtreeModel = await SubtreeModels_1.SubtreeModels.resolve(implicitTiling, schema, resourceResolver, rootCoordinates);
        // The path is composed from the path of the parent and the string
        // representation of the root coordinates
        const coordinateString = ImplicitTilings_1.ImplicitTilings.createString(rootCoordinates);
        const path = `${parent.path}/${coordinateString}`;
        const root = new ImplicitTraversedTile_1.ImplicitTraversedTile(implicitTiling, resourceResolver, parent, path, subtreeModel, parent.level + 1, rootCoordinates, rootCoordinates, rootCoordinates, parent);
        return root;
    }
}
exports.ExplicitTraversedTiles = ExplicitTraversedTiles;
